
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/bottlenoselabs/c2cs (v2.3.1.0)
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
#nullable enable
#pragma warning disable 1591
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using static bottlenoselabs.FAudio.Runtime;

namespace bottlenoselabs
{
    public static unsafe partial class FAudio
    {
        private const string LibraryName = "FAudio";

        // Function @ F3DAudio.h:236:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void F3DAudioInitialize(uint SpeakerChannelMask, float SpeedOfSound, F3DAUDIO_HANDLE Instance);

        // Function @ F3DAudio.h:242:22
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint F3DAudioInitialize8(uint SpeakerChannelMask, float SpeedOfSound, F3DAUDIO_HANDLE Instance);

        // Function @ F3DAudio.h:248:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void F3DAudioCalculate(F3DAUDIO_HANDLE Instance, F3DAUDIO_LISTENER* pListener, F3DAUDIO_EMITTER* pEmitter, uint Flags, F3DAUDIO_DSP_SETTINGS* pDSPSettings);

        // Function @ FAudio.h:498:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioLinkedVersion();

        // Function @ FAudio.h:510:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCreate(FAudioSystem** ppFAudio, uint Flags, FAudioProcessor XAudio2Processor);

        // Function @ FAudio.h:517:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCOMConstructEXT(FAudioSystem** ppFAudio, byte version);

        // Function @ FAudio.h:522:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_AddRef(FAudioSystem* audio);

        // Function @ FAudio.h:527:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_Release(FAudioSystem* audio);

        // Function @ FAudio.h:535:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_GetDeviceCount(FAudioSystem* audio, uint* pCount);

        // Function @ FAudio.h:544:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_GetDeviceDetails(FAudioSystem* audio, uint Index, FAudioDeviceDetails* pDeviceDetails);

        // Function @ FAudio.h:553:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_Initialize(FAudioSystem* audio, uint Flags, FAudioProcessor XAudio2Processor);

        // Function @ FAudio.h:567:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_RegisterForCallbacks(FAudioSystem* audio, FAudioEngineCallback* pCallback);

        // Function @ FAudio.h:579:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudio_UnregisterForCallbacks(FAudioSystem* audio, FAudioEngineCallback* pCallback);

        // Function @ FAudio.h:608:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_CreateSourceVoice(FAudioSystem* audio, FAudioSourceVoice** ppSourceVoice, FAudioWaveFormatEx* pSourceFormat, uint Flags, float MaxFrequencyRatio, FAudioVoiceCallback* pCallback, FAudioVoiceSends* pSendList, FAudioEffectChain* pEffectChain);

        // Function @ FAudio.h:637:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_CreateSubmixVoice(FAudioSystem* audio, FAudioSubmixVoice** ppSubmixVoice, uint InputChannels, uint InputSampleRate, uint Flags, uint ProcessingStage, FAudioVoiceSends* pSendList, FAudioEffectChain* pEffectChain);

        // Function @ FAudio.h:660:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_CreateMasteringVoice(FAudioSystem* audio, FAudioMasteringVoice** ppMasteringVoice, uint InputChannels, uint InputSampleRate, uint Flags, uint DeviceIndex, FAudioEffectChain* pEffectChain);

        // Function @ FAudio.h:673:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_CreateMasteringVoice8(FAudioSystem* audio, FAudioMasteringVoice** ppMasteringVoice, uint InputChannels, uint InputSampleRate, uint Flags, ushort* szDeviceId, FAudioEffectChain* pEffectChain, FAudioStreamCategory StreamCategory);

        // Function @ FAudio.h:687:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_StartEngine(FAudioSystem* audio);

        // Function @ FAudio.h:694:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudio_StopEngine(FAudioSystem* audio);

        // Function @ FAudio.h:707:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_CommitOperationSet(FAudioSystem* audio, uint OperationSet);

        // Function @ FAudio.h:714:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudio_CommitChanges(FAudioSystem* audio);

        // Function @ FAudio.h:720:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudio_GetPerformanceData(FAudioSystem* audio, FAudioPerformanceData* pPerfData);

        // Function @ FAudio.h:731:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudio_SetDebugConfiguration(FAudioSystem* audio, FAudioDebugConfiguration* pDebugConfiguration, void* pReserved);

        // Function @ FAudio.h:745:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudio_GetProcessingQuantum(FAudioSystem* audio, uint* quantumNumerator, uint* quantumDenominator);

        // Function @ FAudio.h:757:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioVoice_GetVoiceDetails(FAudioVoice* voice, FAudioVoiceDetails* pVoiceDetails);

        // Function @ FAudio.h:770:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_SetOutputVoices(FAudioVoice* voice, FAudioVoiceSends* pSendList);

        // Function @ FAudio.h:784:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_SetEffectChain(FAudioVoice* voice, FAudioEffectChain* pEffectChain);

        // Function @ FAudio.h:796:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_EnableEffect(FAudioVoice* voice, uint EffectIndex, uint OperationSet);

        // Function @ FAudio.h:809:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_DisableEffect(FAudioVoice* voice, uint EffectIndex, uint OperationSet);

        // Function @ FAudio.h:822:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioVoice_GetEffectState(FAudioVoice* voice, uint EffectIndex, int* pEnabled);

        // Function @ FAudio.h:837:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_SetEffectParameters(FAudioVoice* voice, uint EffectIndex, void* pParameters, uint ParametersByteSize, uint OperationSet);

        // Function @ FAudio.h:853:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_GetEffectParameters(FAudioVoice* voice, uint EffectIndex, void* pParameters, uint ParametersByteSize);

        // Function @ FAudio.h:868:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_SetFilterParameters(FAudioVoice* voice, FAudioFilterParameters* pParameters, uint OperationSet);

        // Function @ FAudio.h:879:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioVoice_GetFilterParameters(FAudioVoice* voice, FAudioFilterParameters* pParameters);

        // Function @ FAudio.h:893:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_SetOutputFilterParameters(FAudioVoice* voice, FAudioVoice* pDestinationVoice, FAudioFilterParameters* pParameters, uint OperationSet);

        // Function @ FAudio.h:906:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioVoice_GetOutputFilterParameters(FAudioVoice* voice, FAudioVoice* pDestinationVoice, FAudioFilterParameters* pParameters);

        // Function @ FAudio.h:921:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_SetVolume(FAudioVoice* voice, float Volume, uint OperationSet);

        // Function @ FAudio.h:931:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioVoice_GetVolume(FAudioVoice* voice, float* pVolume);

        // Function @ FAudio.h:944:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_SetChannelVolumes(FAudioVoice* voice, uint Channels, float* pVolumes, uint OperationSet);

        // Function @ FAudio.h:956:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioVoice_GetChannelVolumes(FAudioVoice* voice, uint Channels, float* pVolumes);

        // Function @ FAudio.h:979:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioVoice_SetOutputMatrix(FAudioVoice* voice, FAudioVoice* pDestinationVoice, uint SourceChannels, uint DestinationChannels, float* pLevelMatrix, uint OperationSet);

        // Function @ FAudio.h:995:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioVoice_GetOutputMatrix(FAudioVoice* voice, FAudioVoice* pDestinationVoice, uint SourceChannels, uint DestinationChannels, float* pLevelMatrix);

        // Function @ FAudio.h:1004:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioVoice_DestroyVoice(FAudioVoice* voice);

        // Function @ FAudio.h:1015:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioSourceVoice_Start(FAudioSourceVoice* voice, uint Flags, uint OperationSet);

        // Function @ FAudio.h:1030:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioSourceVoice_Stop(FAudioSourceVoice* voice, uint Flags, uint OperationSet);

        // Function @ FAudio.h:1043:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioSourceVoice_SubmitSourceBuffer(FAudioSourceVoice* voice, FAudioBuffer* pBuffer, FAudioBufferWMA* pBufferWMA);

        // Function @ FAudio.h:1055:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioSourceVoice_FlushSourceBuffers(FAudioSourceVoice* voice);

        // Function @ FAudio.h:1063:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioSourceVoice_Discontinuity(FAudioSourceVoice* voice);

        // Function @ FAudio.h:1073:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioSourceVoice_ExitLoop(FAudioSourceVoice* voice, uint OperationSet);

        // Function @ FAudio.h:1083:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioSourceVoice_GetState(FAudioSourceVoice* voice, FAudioVoiceState* pVoiceState, uint Flags);

        // Function @ FAudio.h:1096:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioSourceVoice_SetFrequencyRatio(FAudioSourceVoice* voice, float Ratio, uint OperationSet);

        // Function @ FAudio.h:1106:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudioSourceVoice_GetFrequencyRatio(FAudioSourceVoice* voice, float* pRatio);

        // Function @ FAudio.h:1122:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioSourceVoice_SetSourceSampleRate(FAudioSourceVoice* voice, uint NewSourceSampleRate);

        // Function @ FAudio.h:1137:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioMasteringVoice_GetChannelMask(FAudioMasteringVoice* voice, uint* pChannelMask);

        // Function @ FAudio.h:1251:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCreateWithCustomAllocatorEXT(FAudioSystem** ppFAudio, uint Flags, FAudioProcessor XAudio2Processor, FAudioMallocFunc customMalloc, FAudioFreeFunc customFree, FAudioReallocFunc customRealloc);

        // Function @ FAudio.h:1259:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCOMConstructWithCustomAllocatorEXT(FAudioSystem** ppFAudio, byte version, FAudioMallocFunc customMalloc, FAudioFreeFunc customFree, FAudioReallocFunc customRealloc);

        // Function @ FAudio.h:1273:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudio_SetEngineProcedureEXT(FAudioSystem* audio, FAudioEngineProcedureEXT clientEngineProc, void* user);

        // Function @ FAudio.h:1311:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern FAudioIOStream* FAudio_fopen(CString path);

        // Function @ FAudio.h:1312:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern FAudioIOStream* FAudio_memopen(void* mem, int len);

        // Function @ FAudio.h:1313:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* FAudio_memptr(FAudioIOStream* io, ulong offset);

        // Function @ FAudio.h:1314:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAudio_close(FAudioIOStream* io);

        // Function @ FACT.h:462:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCreateEngine(uint dwCreationFlags, FACTAudioEngine** ppEngine);

        // Function @ FACT.h:468:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCreateEngineWithCustomAllocatorEXT(uint dwCreationFlags, FACTAudioEngine** ppEngine, FAudioMallocFunc customMalloc, FAudioFreeFunc customFree, FAudioReallocFunc customRealloc);

        // Function @ FACT.h:476:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_AddRef(FACTAudioEngine* pEngine);

        // Function @ FACT.h:478:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_Release(FACTAudioEngine* pEngine);

        // Function @ FACT.h:482:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_GetRendererCount(FACTAudioEngine* pEngine, ushort* pnRendererCount);

        // Function @ FACT.h:487:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_GetRendererDetails(FACTAudioEngine* pEngine, ushort nRendererIndex, FACTRendererDetails* pRendererDetails);

        // Function @ FACT.h:493:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_GetFinalMixFormat(FACTAudioEngine* pEngine, FAudioWaveFormatExtensible* pFinalMixFormat);

        // Function @ FACT.h:498:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_Initialize(FACTAudioEngine* pEngine, FACTRuntimeParameters* pParams);

        // Function @ FACT.h:503:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_ShutDown(FACTAudioEngine* pEngine);

        // Function @ FACT.h:505:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_DoWork(FACTAudioEngine* pEngine);

        // Function @ FACT.h:507:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_CreateSoundBank(FACTAudioEngine* pEngine, void* pvBuffer, uint dwSize, uint dwFlags, uint dwAllocAttributes, FACTSoundBank** ppSoundBank);

        // Function @ FACT.h:516:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_CreateInMemoryWaveBank(FACTAudioEngine* pEngine, void* pvBuffer, uint dwSize, uint dwFlags, uint dwAllocAttributes, FACTWaveBank** ppWaveBank);

        // Function @ FACT.h:525:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_CreateStreamingWaveBank(FACTAudioEngine* pEngine, FACTStreamingParameters* pParms, FACTWaveBank** ppWaveBank);

        // Function @ FACT.h:531:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_PrepareWave(FACTAudioEngine* pEngine, uint dwFlags, CString szWavePath, uint wStreamingPacketSize, uint dwAlignment, uint dwPlayOffset, byte nLoopCount, FACTWave** ppWave);

        // Function @ FACT.h:542:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_PrepareInMemoryWave(FACTAudioEngine* pEngine, uint dwFlags, FACTWaveBankEntry entry, uint* pdwSeekTable, byte* pbWaveData, uint dwPlayOffset, byte nLoopCount, FACTWave** ppWave);

        // Function @ FACT.h:553:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_PrepareStreamingWave(FACTAudioEngine* pEngine, uint dwFlags, FACTWaveBankEntry entry, FACTStreamingParameters streamingParams, uint dwAlignment, uint* pdwSeekTable, byte* pbWaveData, uint dwPlayOffset, byte nLoopCount, FACTWave** ppWave);

        // Function @ FACT.h:566:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_RegisterNotification(FACTAudioEngine* pEngine, FACTNotificationDescription* pNotificationDescription);

        // Function @ FACT.h:571:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_UnRegisterNotification(FACTAudioEngine* pEngine, FACTNotificationDescription* pNotificationDescription);

        // Function @ FACT.h:576:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort FACTAudioEngine_GetCategory(FACTAudioEngine* pEngine, CString szFriendlyName);

        // Function @ FACT.h:581:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_Stop(FACTAudioEngine* pEngine, ushort nCategory, uint dwFlags);

        // Function @ FACT.h:587:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_SetVolume(FACTAudioEngine* pEngine, ushort nCategory, float volume);

        // Function @ FACT.h:593:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_Pause(FACTAudioEngine* pEngine, ushort nCategory, int fPause);

        // Function @ FACT.h:599:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort FACTAudioEngine_GetGlobalVariableIndex(FACTAudioEngine* pEngine, CString szFriendlyName);

        // Function @ FACT.h:604:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_SetGlobalVariable(FACTAudioEngine* pEngine, ushort nIndex, float nValue);

        // Function @ FACT.h:610:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTAudioEngine_GetGlobalVariable(FACTAudioEngine* pEngine, ushort nIndex, float* pnValue);

        // Function @ FACT.h:618:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort FACTSoundBank_GetCueIndex(FACTSoundBank* pSoundBank, CString szFriendlyName);

        // Function @ FACT.h:623:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTSoundBank_GetNumCues(FACTSoundBank* pSoundBank, ushort* pnNumCues);

        // Function @ FACT.h:628:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTSoundBank_GetCueProperties(FACTSoundBank* pSoundBank, ushort nCueIndex, FACTCueProperties* pProperties);

        // Function @ FACT.h:634:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTSoundBank_Prepare(FACTSoundBank* pSoundBank, ushort nCueIndex, uint dwFlags, int timeOffset, FACTCue** ppCue);

        // Function @ FACT.h:642:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTSoundBank_Play(FACTSoundBank* pSoundBank, ushort nCueIndex, uint dwFlags, int timeOffset, FACTCue** ppCue);

        // Function @ FACT.h:655:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTSoundBank_Play3D(FACTSoundBank* pSoundBank, ushort nCueIndex, uint dwFlags, int timeOffset, F3DAUDIO_DSP_SETTINGS* pDSPSettings, FACTCue** ppCue);

        // Function @ FACT.h:664:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTSoundBank_Stop(FACTSoundBank* pSoundBank, ushort nCueIndex, uint dwFlags);

        // Function @ FACT.h:670:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTSoundBank_Destroy(FACTSoundBank* pSoundBank);

        // Function @ FACT.h:672:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTSoundBank_GetState(FACTSoundBank* pSoundBank, uint* pdwState);

        // Function @ FACT.h:679:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWaveBank_Destroy(FACTWaveBank* pWaveBank);

        // Function @ FACT.h:681:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWaveBank_GetState(FACTWaveBank* pWaveBank, uint* pdwState);

        // Function @ FACT.h:686:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWaveBank_GetNumWaves(FACTWaveBank* pWaveBank, ushort* pnNumWaves);

        // Function @ FACT.h:691:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort FACTWaveBank_GetWaveIndex(FACTWaveBank* pWaveBank, CString szFriendlyName);

        // Function @ FACT.h:696:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWaveBank_GetWaveProperties(FACTWaveBank* pWaveBank, ushort nWaveIndex, FACTWaveProperties* pWaveProperties);

        // Function @ FACT.h:702:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWaveBank_Prepare(FACTWaveBank* pWaveBank, ushort nWaveIndex, uint dwFlags, uint dwPlayOffset, byte nLoopCount, FACTWave** ppWave);

        // Function @ FACT.h:711:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWaveBank_Play(FACTWaveBank* pWaveBank, ushort nWaveIndex, uint dwFlags, uint dwPlayOffset, byte nLoopCount, FACTWave** ppWave);

        // Function @ FACT.h:720:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWaveBank_Stop(FACTWaveBank* pWaveBank, ushort nWaveIndex, uint dwFlags);

        // Function @ FACT.h:728:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWave_Destroy(FACTWave* pWave);

        // Function @ FACT.h:730:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWave_Play(FACTWave* pWave);

        // Function @ FACT.h:732:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWave_Stop(FACTWave* pWave, uint dwFlags);

        // Function @ FACT.h:734:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWave_Pause(FACTWave* pWave, int fPause);

        // Function @ FACT.h:736:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWave_GetState(FACTWave* pWave, uint* pdwState);

        // Function @ FACT.h:738:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWave_SetPitch(FACTWave* pWave, short pitch);

        // Function @ FACT.h:740:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWave_SetVolume(FACTWave* pWave, float volume);

        // Function @ FACT.h:742:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWave_SetMatrixCoefficients(FACTWave* pWave, uint uSrcChannelCount, uint uDstChannelCount, float* pMatrixCoefficients);

        // Function @ FACT.h:749:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTWave_GetProperties(FACTWave* pWave, FACTWaveInstanceProperties* pProperties);

        // Function @ FACT.h:756:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_Destroy(FACTCue* pCue);

        // Function @ FACT.h:758:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_Play(FACTCue* pCue);

        // Function @ FACT.h:760:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_Stop(FACTCue* pCue, uint dwFlags);

        // Function @ FACT.h:762:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_GetState(FACTCue* pCue, uint* pdwState);

        // Function @ FACT.h:764:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_SetMatrixCoefficients(FACTCue* pCue, uint uSrcChannelCount, uint uDstChannelCount, float* pMatrixCoefficients);

        // Function @ FACT.h:771:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort FACTCue_GetVariableIndex(FACTCue* pCue, CString szFriendlyName);

        // Function @ FACT.h:776:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_SetVariable(FACTCue* pCue, ushort nIndex, float nValue);

        // Function @ FACT.h:782:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_GetVariable(FACTCue* pCue, ushort nIndex, float* nValue);

        // Function @ FACT.h:788:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_Pause(FACTCue* pCue, int fPause);

        // Function @ FACT.h:790:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_GetProperties(FACTCue* pCue, FACTCueInstanceProperties** ppProperties);

        // Function @ FACT.h:795:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_SetOutputVoices(FACTCue* pCue, FAudioVoiceSends* pSendList);

        // Function @ FACT.h:800:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACTCue_SetOutputVoiceMatrix(FACTCue* pCue, FAudioVoice* pDestinationVoice, uint SourceChannels, uint DestinationChannels, float* pLevelMatrix);

        // Function @ FACT3D.h:104:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACT3DInitialize(FACTAudioEngine* pEngine, F3DAUDIO_HANDLE F3DInstance);

        // Function @ FACT3D.h:109:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACT3DCalculate(F3DAUDIO_HANDLE F3DInstance, F3DAUDIO_LISTENER* pListener, F3DAUDIO_EMITTER* pEmitter, F3DAUDIO_DSP_SETTINGS* pDSPSettings);

        // Function @ FACT3D.h:116:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FACT3DApply(F3DAUDIO_DSP_SETTINGS* pDSPSettings, FACTCue* pCue);

        // Function @ FAPOBase.h:140:14
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void CreateFAPOBase(FAPOBase* fapo, FAPORegistrationProperties* pRegistrationProperties, byte* pParameterBlocks, uint uParameterBlockByteSize, byte fProducer);

        // Function @ FAPOBase.h:149:14
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void CreateFAPOBaseWithCustomAllocatorEXT(FAPOBase* fapo, FAPORegistrationProperties* pRegistrationProperties, byte* pParameterBlocks, uint uParameterBlockByteSize, byte fProducer, FAudioMallocFunc customMalloc, FAudioFreeFunc customFree, FAudioReallocFunc customRealloc);

        // Function @ FAPOBase.h:160:17
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int FAPOBase_AddRef(FAPOBase* fapo);

        // Function @ FAPOBase.h:162:17
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int FAPOBase_Release(FAPOBase* fapo);

        // Function @ FAPOBase.h:164:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOBase_GetRegistrationProperties(FAPOBase* fapo, FAPORegistrationProperties** ppRegistrationProperties);

        // Function @ FAPOBase.h:169:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOBase_IsInputFormatSupported(FAPOBase* fapo, FAudioWaveFormatEx* pOutputFormat, FAudioWaveFormatEx* pRequestedInputFormat, FAudioWaveFormatEx** ppSupportedInputFormat);

        // Function @ FAPOBase.h:176:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOBase_IsOutputFormatSupported(FAPOBase* fapo, FAudioWaveFormatEx* pInputFormat, FAudioWaveFormatEx* pRequestedOutputFormat, FAudioWaveFormatEx** ppSupportedOutputFormat);

        // Function @ FAPOBase.h:183:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOBase_Initialize(FAPOBase* fapo, void* pData, uint DataByteSize);

        // Function @ FAPOBase.h:189:14
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAPOBase_Reset(FAPOBase* fapo);

        // Function @ FAPOBase.h:191:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOBase_LockForProcess(FAPOBase* fapo, uint InputLockedParameterCount, FAPOLockForProcessBufferParameters* pInputLockedParameters, uint OutputLockedParameterCount, FAPOLockForProcessBufferParameters* pOutputLockedParameters);

        // Function @ FAPOBase.h:199:14
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAPOBase_UnlockForProcess(FAPOBase* fapo);

        // Function @ FAPOBase.h:201:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOBase_CalcInputFrames(FAPOBase* fapo, uint OutputFrameCount);

        // Function @ FAPOBase.h:206:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOBase_CalcOutputFrames(FAPOBase* fapo, uint InputFrameCount);

        // Function @ FAPOBase.h:211:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOBase_ValidateFormatDefault(FAPOBase* fapo, FAudioWaveFormatEx* pFormat, byte fOverwrite);

        // Function @ FAPOBase.h:217:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOBase_ValidateFormatPair(FAPOBase* fapo, FAudioWaveFormatEx* pSupportedFormat, FAudioWaveFormatEx* pRequestedFormat, byte fOverwrite);

        // Function @ FAPOBase.h:224:14
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAPOBase_ProcessThru(FAPOBase* fapo, void* pInputBuffer, float* pOutputBuffer, uint FrameCount, ushort InputChannelCount, ushort OutputChannelCount, byte MixWithOutput);

        // Function @ FAPOBase.h:234:14
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAPOBase_SetParameters(FAPOBase* fapo, void* pParameters, uint ParameterByteSize);

        // Function @ FAPOBase.h:240:14
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAPOBase_GetParameters(FAPOBase* fapo, void* pParameters, uint ParameterByteSize);

        // Function @ FAPOBase.h:246:14
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAPOBase_OnSetParameters(FAPOBase* fapo, void* parameters, uint parametersSize);

        // Function @ FAPOBase.h:252:17
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern byte FAPOBase_ParametersChanged(FAPOBase* fapo);

        // Function @ FAPOBase.h:254:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* FAPOBase_BeginProcess(FAPOBase* fapo);

        // Function @ FAPOBase.h:256:14
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void FAPOBase_EndProcess(FAPOBase* fapo);

        // Function @ FAPOFX.h:154:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOFX_CreateFX(FAudioGUID* clsid, FAPO** pEffect, void* pInitData, uint InitDataByteSize);

        // Function @ FAPOFX.h:162:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAPOFX_CreateFXWithCustomAllocatorEXT(FAudioGUID* clsid, FAPO** pEffect, void* pInitData, uint InitDataByteSize, FAudioMallocFunc customMalloc, FAudioFreeFunc customFree, FAudioReallocFunc customRealloc);

        // Function @ FAudioFX.h:265:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCreateVolumeMeter(FAPO** ppApo, uint Flags);

        // Function @ FAudioFX.h:266:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCreateReverb(FAPO** ppApo, uint Flags);

        // Function @ FAudioFX.h:267:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCreateReverb9(FAPO** ppApo, uint Flags);

        // Function @ FAudioFX.h:270:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCreateVolumeMeterWithCustomAllocatorEXT(FAPO** ppApo, uint Flags, FAudioMallocFunc customMalloc, FAudioFreeFunc customFree, FAudioReallocFunc customRealloc);

        // Function @ FAudioFX.h:277:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCreateReverbWithCustomAllocatorEXT(FAPO** ppApo, uint Flags, FAudioMallocFunc customMalloc, FAudioFreeFunc customFree, FAudioReallocFunc customRealloc);

        // Function @ FAudioFX.h:284:20
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint FAudioCreateReverb9WithCustomAllocatorEXT(FAPO** ppApo, uint Flags, FAudioMallocFunc customMalloc, FAudioFreeFunc customFree, FAudioReallocFunc customRealloc);

        // Function @ FAudioFX.h:292:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReverbConvertI3DL2ToNative(FAudioFXReverbI3DL2Parameters* pI3DL2, FAudioFXReverbParameters* pNative);

        // Function @ FAudioFX.h:296:16
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void ReverbConvertI3DL2ToNative9(FAudioFXReverbI3DL2Parameters* pI3DL2, FAudioFXReverbParameters9* pNative, int sevenDotOneReverb);

        // FunctionPointer @ FAudio.h:1247:29
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioMallocFunc
        {
            public delegate* unmanaged<ulong, void*> Pointer;
        }

        // FunctionPointer @ FAudio.h:1248:28
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioFreeFunc
        {
            public delegate* unmanaged<void*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1249:29
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioReallocFunc
        {
            public delegate* unmanaged<void*, ulong, void*> Pointer;
        }

        // FunctionPointer @ FAudio.h:1271:27
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioEngineProcedureEXT
        {
            public delegate* unmanaged<FAudioEngineCallEXT, FAudioSystem*, float*, void*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1148:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnCriticalErrorFunc
        {
            public delegate* unmanaged<FAudioEngineCallback*, uint, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1154:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnProcessingPassEndFunc
        {
            public delegate* unmanaged<FAudioEngineCallback*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1159:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnProcessingPassStartFunc
        {
            public delegate* unmanaged<FAudioEngineCallback*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1176:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnBufferEndFunc
        {
            public delegate* unmanaged<FAudioVoiceCallback*, void*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1185:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnBufferStartFunc
        {
            public delegate* unmanaged<FAudioVoiceCallback*, void*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1194:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnLoopEndFunc
        {
            public delegate* unmanaged<FAudioVoiceCallback*, void*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1200:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnStreamEndFunc
        {
            public delegate* unmanaged<FAudioVoiceCallback*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1209:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnVoiceErrorFunc
        {
            public delegate* unmanaged<FAudioVoiceCallback*, void*, uint, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1216:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnVoiceProcessingPassEndFunc
        {
            public delegate* unmanaged<FAudioVoiceCallback*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1227:28
        [StructLayout(LayoutKind.Sequential)]
        public struct OnVoiceProcessingPassStartFunc
        {
            public delegate* unmanaged<FAudioVoiceCallback*, uint, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1270:27
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioEngineCallEXT
        {
            public delegate* unmanaged<FAudioSystem*, float*, void> Pointer;
        }

        // FunctionPointer @ FAudio.h:1287:30
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudio_readfunc
        {
            public delegate* unmanaged<void*, void*, ulong, ulong, ulong> Pointer;
        }

        // FunctionPointer @ FAudio.h:1293:31
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudio_seekfunc
        {
            public delegate* unmanaged<void*, long, int, long> Pointer;
        }

        // FunctionPointer @ FAudio.h:1298:27
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudio_closefunc
        {
            public delegate* unmanaged<void*, int> Pointer;
        }

        // FunctionPointer @ FACT.h:100:26
        [StructLayout(LayoutKind.Sequential)]
        public struct FACTNotificationCallback
        {
            public delegate* unmanaged<FACTNotification*, void> Pointer;
        }

        // FunctionPointer @ FAPOBase.h:110:18
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Void
        {
            public delegate* unmanaged<void*, void> Pointer;
        }

        // FunctionPointer @ FAPOBase.h:99:26
        [StructLayout(LayoutKind.Sequential)]
        public struct OnSetParametersFunc
        {
            public delegate* unmanaged<FAPOBase*, void*, uint, void> Pointer;
        }

        // FunctionPointer @ FAPO.h:116:29
        [StructLayout(LayoutKind.Sequential)]
        public struct AddRefFunc
        {
            public delegate* unmanaged<void*, int> Pointer;
        }

        // FunctionPointer @ FAPO.h:119:29
        [StructLayout(LayoutKind.Sequential)]
        public struct ReleaseFunc
        {
            public delegate* unmanaged<void*, int> Pointer;
        }

        // FunctionPointer @ FAPO.h:122:30
        [StructLayout(LayoutKind.Sequential)]
        public struct GetRegistrationPropertiesFunc
        {
            public delegate* unmanaged<void*, FAPORegistrationProperties**, uint> Pointer;
        }

        // FunctionPointer @ FAPO.h:126:30
        [StructLayout(LayoutKind.Sequential)]
        public struct IsInputFormatSupportedFunc
        {
            public delegate* unmanaged<void*, FAudioWaveFormatEx*, FAudioWaveFormatEx*, FAudioWaveFormatEx**, uint> Pointer;
        }

        // FunctionPointer @ FAPO.h:132:30
        [StructLayout(LayoutKind.Sequential)]
        public struct IsOutputFormatSupportedFunc
        {
            public delegate* unmanaged<void*, FAudioWaveFormatEx*, FAudioWaveFormatEx*, FAudioWaveFormatEx**, uint> Pointer;
        }

        // FunctionPointer @ FAPO.h:138:30
        [StructLayout(LayoutKind.Sequential)]
        public struct InitializeFunc
        {
            public delegate* unmanaged<void*, void*, uint, uint> Pointer;
        }

        // FunctionPointer @ FAPO.h:143:26
        [StructLayout(LayoutKind.Sequential)]
        public struct ResetFunc
        {
            public delegate* unmanaged<void*, void> Pointer;
        }

        // FunctionPointer @ FAPO.h:146:30
        [StructLayout(LayoutKind.Sequential)]
        public struct LockForProcessFunc
        {
            public delegate* unmanaged<void*, uint, FAPOLockForProcessBufferParameters*, uint, FAPOLockForProcessBufferParameters*, uint> Pointer;
        }

        // FunctionPointer @ FAPO.h:153:26
        [StructLayout(LayoutKind.Sequential)]
        public struct UnlockForProcessFunc
        {
            public delegate* unmanaged<void*, void> Pointer;
        }

        // FunctionPointer @ FAPO.h:156:26
        [StructLayout(LayoutKind.Sequential)]
        public struct ProcessFunc
        {
            public delegate* unmanaged<void*, uint, FAPOProcessBufferParameters*, uint, FAPOProcessBufferParameters*, int, void> Pointer;
        }

        // FunctionPointer @ FAPO.h:164:30
        [StructLayout(LayoutKind.Sequential)]
        public struct CalcInputFramesFunc
        {
            public delegate* unmanaged<void*, uint, uint> Pointer;
        }

        // FunctionPointer @ FAPO.h:168:30
        [StructLayout(LayoutKind.Sequential)]
        public struct CalcOutputFramesFunc
        {
            public delegate* unmanaged<void*, uint, uint> Pointer;
        }

        // FunctionPointer @ FAPO.h:172:26
        [StructLayout(LayoutKind.Sequential)]
        public struct SetParametersFunc
        {
            public delegate* unmanaged<void*, void*, uint, void> Pointer;
        }

        // FunctionPointer @ FAPO.h:177:26
        [StructLayout(LayoutKind.Sequential)]
        public struct GetParametersFunc
        {
            public delegate* unmanaged<void*, void*, uint, void> Pointer;
        }

        // FunctionPointer @ FACT.h:79:29
        [StructLayout(LayoutKind.Sequential)]
        public struct FACTReadFileCallback
        {
            public delegate* unmanaged<void*, void*, uint, uint*, FACTOverlapped*, int> Pointer;
        }

        // FunctionPointer @ FACT.h:87:29
        [StructLayout(LayoutKind.Sequential)]
        public struct FACTGetOverlappedResultCallback
        {
            public delegate* unmanaged<void*, FACTOverlapped*, uint*, int, int> Pointer;
        }

        // Struct @ F3DAudio.h:188:3
        [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 1)]
        public struct F3DAUDIO_LISTENER
        {
            [FieldOffset(0)] // size = 12, padding = 0
            public F3DAUDIO_VECTOR OrientFront;

            [FieldOffset(12)] // size = 12, padding = 0
            public F3DAUDIO_VECTOR OrientTop;

            [FieldOffset(24)] // size = 12, padding = 0
            public F3DAUDIO_VECTOR Position;

            [FieldOffset(36)] // size = 12, padding = 0
            public F3DAUDIO_VECTOR Velocity;

            [FieldOffset(48)] // size = 8, padding = 0
            public F3DAUDIO_CONE* pCone;
        }

        // Struct @ F3DAudio.h:209:3
        [StructLayout(LayoutKind.Explicit, Size = 128, Pack = 1)]
        public struct F3DAUDIO_EMITTER
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public F3DAUDIO_CONE* pCone;

            [FieldOffset(8)] // size = 12, padding = 0
            public F3DAUDIO_VECTOR OrientFront;

            [FieldOffset(20)] // size = 12, padding = 0
            public F3DAUDIO_VECTOR OrientTop;

            [FieldOffset(32)] // size = 12, padding = 0
            public F3DAUDIO_VECTOR Position;

            [FieldOffset(44)] // size = 12, padding = 0
            public F3DAUDIO_VECTOR Velocity;

            [FieldOffset(56)] // size = 4, padding = 0
            public float InnerRadius;

            [FieldOffset(60)] // size = 4, padding = 0
            public float InnerRadiusAngle;

            [FieldOffset(64)] // size = 4, padding = 0
            public uint ChannelCount;

            [FieldOffset(68)] // size = 4, padding = 0
            public float ChannelRadius;

            [FieldOffset(72)] // size = 8, padding = 0
            public float* pChannelAzimuths;

            [FieldOffset(80)] // size = 8, padding = 0
            public F3DAUDIO_DISTANCE_CURVE* pVolumeCurve;

            [FieldOffset(88)] // size = 8, padding = 0
            public F3DAUDIO_DISTANCE_CURVE* pLFECurve;

            [FieldOffset(96)] // size = 8, padding = 0
            public F3DAUDIO_DISTANCE_CURVE* pLPFDirectCurve;

            [FieldOffset(104)] // size = 8, padding = 0
            public F3DAUDIO_DISTANCE_CURVE* pLPFReverbCurve;

            [FieldOffset(112)] // size = 8, padding = 0
            public F3DAUDIO_DISTANCE_CURVE* pReverbCurve;

            [FieldOffset(120)] // size = 4, padding = 0
            public float CurveDistanceScaler;

            [FieldOffset(124)] // size = 4, padding = 0
            public float DopplerScaler;
        }

        // Struct @ F3DAudio.h:213:38
        [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 1)]
        public struct F3DAUDIO_DSP_SETTINGS
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public float* pMatrixCoefficients;

            [FieldOffset(8)] // size = 8, padding = 0
            public float* pDelayTimes;

            [FieldOffset(16)] // size = 4, padding = 0
            public uint SrcChannelCount;

            [FieldOffset(20)] // size = 4, padding = 0
            public uint DstChannelCount;

            [FieldOffset(24)] // size = 4, padding = 0
            public float LPFDirectCoefficient;

            [FieldOffset(28)] // size = 4, padding = 0
            public float LPFReverbCoefficient;

            [FieldOffset(32)] // size = 4, padding = 0
            public float ReverbLevel;

            [FieldOffset(36)] // size = 4, padding = 0
            public float DopplerFactor;

            [FieldOffset(40)] // size = 4, padding = 0
            public float EmitterToListenerAngle;

            [FieldOffset(44)] // size = 4, padding = 0
            public float EmitterToListenerDistance;

            [FieldOffset(48)] // size = 4, padding = 0
            public float EmitterVelocityComponent;

            [FieldOffset(52)] // size = 4, padding = 0
            public float ListenerVelocityComponent;
        }

        // Struct @ FAudio.h:121:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 1)]
        public struct FAudioGUID
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint Data1;

            [FieldOffset(4)] // size = 2, padding = 0
            public ushort Data2;

            [FieldOffset(6)] // size = 2, padding = 0
            public ushort Data3;

            [FieldOffset(8)] // size = 8, padding = 0
            public fixed byte _Data4[8 / 1]; // uint8_t[8]

            public Span<byte> Data4
            {
                get
                {
                    fixed (FAudioGUID* @this = &this)
                    {
                        var pointer = &@this->_Data4[0];
                        var span = new Span<byte>(pointer, 8);
                        return span;
                    }
                }
            }
        }

        // Struct @ FAudio.h:195:3
        [StructLayout(LayoutKind.Explicit, Size = 1068, Pack = 1)]
        public struct FAudioDeviceDetails
        {
            [FieldOffset(0)] // size = 512, padding = 0
            public fixed ushort _DeviceID[512 / 2]; // int16_t[256]

            public Span<short> DeviceID
            {
                get
                {
                    fixed (FAudioDeviceDetails* @this = &this)
                    {
                        var pointer = &@this->_DeviceID[0];
                        var span = new Span<short>(pointer, 256);
                        return span;
                    }
                }
            }

            [FieldOffset(512)] // size = 512, padding = 0
            public fixed ushort _DisplayName[512 / 2]; // int16_t[256]

            public Span<short> DisplayName
            {
                get
                {
                    fixed (FAudioDeviceDetails* @this = &this)
                    {
                        var pointer = &@this->_DisplayName[0];
                        var span = new Span<short>(pointer, 256);
                        return span;
                    }
                }
            }

            [FieldOffset(1024)] // size = 4, padding = 0
            public FAudioDeviceRole Role;

            [FieldOffset(1028)] // size = 40, padding = 0
            public FAudioWaveFormatExtensible OutputFormat;
        }

        // Struct @ FAudio.h:67:37
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct FAudioEngineCallback
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public OnCriticalErrorFunc OnCriticalError;

            [FieldOffset(8)] // size = 8, padding = 0
            public OnProcessingPassEndFunc OnProcessingPassEnd;

            [FieldOffset(16)] // size = 8, padding = 0
            public OnProcessingPassStartFunc OnProcessingPassStart;
        }

        // Struct @ FAudio.h:135:3
        [StructLayout(LayoutKind.Explicit, Size = 18, Pack = 1)]
        public struct FAudioWaveFormatEx
        {
            [FieldOffset(0)] // size = 2, padding = 0
            public ushort wFormatTag;

            [FieldOffset(2)] // size = 2, padding = 0
            public ushort nChannels;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint nSamplesPerSec;

            [FieldOffset(8)] // size = 4, padding = 0
            public uint nAvgBytesPerSec;

            [FieldOffset(12)] // size = 2, padding = 0
            public ushort nBlockAlign;

            [FieldOffset(14)] // size = 2, padding = 0
            public ushort wBitsPerSample;

            [FieldOffset(16)] // size = 2, padding = 0
            public ushort cbSize;
        }

        // Struct @ FAudio.h:68:36
        [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
        public struct FAudioVoiceCallback
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public OnBufferEndFunc OnBufferEnd;

            [FieldOffset(8)] // size = 8, padding = 0
            public OnBufferStartFunc OnBufferStart;

            [FieldOffset(16)] // size = 8, padding = 0
            public OnLoopEndFunc OnLoopEnd;

            [FieldOffset(24)] // size = 8, padding = 0
            public OnStreamEndFunc OnStreamEnd;

            [FieldOffset(32)] // size = 8, padding = 0
            public OnVoiceErrorFunc OnVoiceError;

            [FieldOffset(40)] // size = 8, padding = 0
            public OnVoiceProcessingPassEndFunc OnVoiceProcessingPassEnd;

            [FieldOffset(48)] // size = 8, padding = 0
            public OnVoiceProcessingPassStartFunc OnVoiceProcessingPassStart;
        }

        // Struct @ FAudio.h:215:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 1)]
        public struct FAudioVoiceSends
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint SendCount;

            [FieldOffset(4)] // size = 8, padding = 0
            public FAudioSendDescriptor* pSends;
        }

        // Struct @ FAudio.h:233:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 1)]
        public struct FAudioEffectChain
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint EffectCount;

            [FieldOffset(4)] // size = 8, padding = 0
            public FAudioEffectDescriptor* pEffectDescriptors;
        }

        // Struct @ FAudio.h:299:3
        [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 1)]
        public struct FAudioPerformanceData
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public ulong AudioCyclesSinceLastQuery;

            [FieldOffset(8)] // size = 8, padding = 0
            public ulong TotalCyclesSinceLastQuery;

            [FieldOffset(16)] // size = 4, padding = 0
            public uint MinimumCyclesPerQuantum;

            [FieldOffset(20)] // size = 4, padding = 0
            public uint MaximumCyclesPerQuantum;

            [FieldOffset(24)] // size = 4, padding = 0
            public uint MemoryUsageInBytes;

            [FieldOffset(28)] // size = 4, padding = 0
            public uint CurrentLatencyInSamples;

            [FieldOffset(32)] // size = 4, padding = 0
            public uint GlitchesSinceEngineStarted;

            [FieldOffset(36)] // size = 4, padding = 0
            public uint ActiveSourceVoiceCount;

            [FieldOffset(40)] // size = 4, padding = 0
            public uint TotalSourceVoiceCount;

            [FieldOffset(44)] // size = 4, padding = 0
            public uint ActiveSubmixVoiceCount;

            [FieldOffset(48)] // size = 4, padding = 0
            public uint ActiveResamplerCount;

            [FieldOffset(52)] // size = 4, padding = 0
            public uint ActiveMatrixMixCount;

            [FieldOffset(56)] // size = 4, padding = 0
            public uint ActiveXmaSourceVoices;

            [FieldOffset(60)] // size = 4, padding = 0
            public uint ActiveXmaStreams;
        }

        // Struct @ FAudio.h:311:3
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 1)]
        public struct FAudioDebugConfiguration
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint TraceMask;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint BreakMask;

            [FieldOffset(8)] // size = 4, padding = 0
            public int LogThreadID;

            [FieldOffset(12)] // size = 4, padding = 0
            public int LogFileline;

            [FieldOffset(16)] // size = 4, padding = 0
            public int LogFunctionName;

            [FieldOffset(20)] // size = 4, padding = 0
            public int LogTiming;
        }

        // Struct @ FAudio.h:203:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 1)]
        public struct FAudioVoiceDetails
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint CreationFlags;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint ActiveFlags;

            [FieldOffset(8)] // size = 4, padding = 0
            public uint InputChannels;

            [FieldOffset(12)] // size = 4, padding = 0
            public uint InputSampleRate;
        }

        // Struct @ FAudio.h:240:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 1)]
        public struct FAudioFilterParameters
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public FAudioFilterType Type;

            [FieldOffset(4)] // size = 4, padding = 0
            public float Frequency;

            [FieldOffset(8)] // size = 4, padding = 0
            public float OneOverQ;
        }

        // Struct @ FAudio.h:268:3
        [StructLayout(LayoutKind.Explicit, Size = 44, Pack = 1)]
        public struct FAudioBuffer
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint Flags;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint AudioBytes;

            [FieldOffset(8)] // size = 8, padding = 0
            public byte* pAudioData;

            [FieldOffset(16)] // size = 4, padding = 0
            public uint PlayBegin;

            [FieldOffset(20)] // size = 4, padding = 0
            public uint PlayLength;

            [FieldOffset(24)] // size = 4, padding = 0
            public uint LoopBegin;

            [FieldOffset(28)] // size = 4, padding = 0
            public uint LoopLength;

            [FieldOffset(32)] // size = 4, padding = 0
            public uint LoopCount;

            [FieldOffset(36)] // size = 8, padding = 0
            public void* pContext;
        }

        // Struct @ FAudio.h:274:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 1)]
        public struct FAudioBufferWMA
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public uint* pDecodedPacketCumulativeBytes;

            [FieldOffset(8)] // size = 4, padding = 0
            public uint PacketCount;
        }

        // Struct @ FAudio.h:281:3
        [StructLayout(LayoutKind.Explicit, Size = 20, Pack = 1)]
        public struct FAudioVoiceState
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* pCurrentBufferContext;

            [FieldOffset(8)] // size = 4, padding = 0
            public uint BuffersQueued;

            [FieldOffset(12)] // size = 8, padding = 0
            public ulong SamplesPlayed;
        }

        // Struct @ FAudio.h:1309:3
        [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
        public struct FAudioIOStream
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* data;

            [FieldOffset(8)] // size = 8, padding = 0
            public FAudio_readfunc read;

            [FieldOffset(16)] // size = 8, padding = 0
            public FAudio_seekfunc seek;

            [FieldOffset(24)] // size = 8, padding = 0
            public FAudio_closefunc close;

            [FieldOffset(32)] // size = 8, padding = 0
            public void* @lock;
        }

        // Struct @ FACT.h:61:3
        [StructLayout(LayoutKind.Explicit, Size = 1024, Pack = 4)]
        public struct FACTRendererDetails
        {
            [FieldOffset(0)] // size = 510, padding = 0
            public fixed ushort _rendererID[510 / 2]; // int16_t[255]

            public Span<short> rendererID
            {
                get
                {
                    fixed (FACTRendererDetails* @this = &this)
                    {
                        var pointer = &@this->_rendererID[0];
                        var span = new Span<short>(pointer, 255);
                        return span;
                    }
                }
            }

            [FieldOffset(510)] // size = 510, padding = 0
            public fixed ushort _displayName[510 / 2]; // int16_t[255]

            public Span<short> displayName
            {
                get
                {
                    fixed (FACTRendererDetails* @this = &this)
                    {
                        var pointer = &@this->_displayName[0];
                        var span = new Span<short>(pointer, 255);
                        return span;
                    }
                }
            }

            [FieldOffset(1020)] // size = 4, padding = 0
            public int defaultDevice;
        }

        // Struct @ FAudio.h:151:3
        [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 1)]
        public struct FAudioWaveFormatExtensible
        {
            [FieldOffset(0)] // size = 18, padding = 0
            public FAudioWaveFormatEx Format;

            [FieldOffset(18)] // size = 2, padding = 0
            public FAudioWaveFormatExtensible_Samples Samples;

            [FieldOffset(20)] // size = 4, padding = 0
            public uint dwChannelMask;

            [FieldOffset(24)] // size = 16, padding = 0
            public FAudioGUID SubFormat;

            // Union @ FAudio.h:143:2
            [StructLayout(LayoutKind.Explicit, Size = 2, Pack = 1)]
            public struct FAudioWaveFormatExtensible_Samples
            {
                [FieldOffset(0)] // size = 2, padding = 0
                public ushort wValidBitsPerSample;

                [FieldOffset(0)] // size = 2, padding = 0
                public ushort wSamplesPerBlock;

                [FieldOffset(0)] // size = 2, padding = 0
                public ushort wReserved;
            }
        }

        // Struct @ FACT.h:117:3
        [StructLayout(LayoutKind.Explicit, Size = 80, Pack = 8)]
        public struct FACTRuntimeParameters
        {
            [FieldOffset(0)] // size = 4, padding = 4
            public uint lookAheadTime;

            [FieldOffset(8)] // size = 8, padding = 0
            public void* pGlobalSettingsBuffer;

            [FieldOffset(16)] // size = 4, padding = 0
            public uint globalSettingsBufferSize;

            [FieldOffset(20)] // size = 4, padding = 0
            public uint globalSettingsFlags;

            [FieldOffset(24)] // size = 4, padding = 4
            public uint globalSettingsAllocAttributes;

            [FieldOffset(32)] // size = 16, padding = 0
            public FACTFileIOCallbacks fileIOCallbacks;

            [FieldOffset(48)] // size = 8, padding = 0
            public FACTNotificationCallback fnNotificationCallback;

            [FieldOffset(56)] // size = 8, padding = 0
            public short* pRendererID;

            [FieldOffset(64)] // size = 8, padding = 0
            public FAudioSystem* pXAudio2;

            [FieldOffset(72)] // size = 8, padding = 0
            public FAudioMasteringVoice* pMasteringVoice;
        }

        // Struct @ FACT.h:125:3
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct FACTStreamingParameters
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* file;

            [FieldOffset(8)] // size = 4, padding = 0
            public uint offset;

            [FieldOffset(12)] // size = 4, padding = 0
            public uint flags;

            [FieldOffset(16)] // size = 2, padding = 6
            public ushort packetSize;
        }

        // Struct @ FACT.h:196:3
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 1)]
        public struct FACTWaveBankEntry
        {
            [FieldOffset(4)] // size = 4, padding = 0
            public FACTWaveBankMiniWaveFormat Format;

            [FieldOffset(8)] // size = 8, padding = 0
            public FACTWaveBankRegion PlayRegion;

            [FieldOffset(16)] // size = 8, padding = 0
            public FACTWaveBankSampleRegion LoopRegion;
        }

        // Struct @ FACT.h:297:3
        [StructLayout(LayoutKind.Explicit, Size = 46, Pack = 1)]
        public struct FACTNotificationDescription
        {
            [FieldOffset(0)] // size = 1, padding = 0
            public byte type;

            [FieldOffset(1)] // size = 1, padding = 0
            public byte flags;

            [FieldOffset(2)] // size = 8, padding = 0
            public FACTSoundBank* pSoundBank;

            [FieldOffset(10)] // size = 8, padding = 0
            public FACTWaveBank* pWaveBank;

            [FieldOffset(18)] // size = 8, padding = 0
            public FACTCue* pCue;

            [FieldOffset(26)] // size = 8, padding = 0
            public FACTWave* pWave;

            [FieldOffset(34)] // size = 2, padding = 0
            public ushort cueIndex;

            [FieldOffset(36)] // size = 2, padding = 0
            public ushort waveIndex;

            [FieldOffset(38)] // size = 8, padding = 0
            public void* pvContext;
        }

        // Struct @ FACT.h:241:3
        [StructLayout(LayoutKind.Explicit, Size = 268, Pack = 4)]
        public struct FACTCueProperties
        {
            [FieldOffset(0)] // size = 255, padding = 1
            public fixed byte _friendlyName[255 / 1]; // char[255]

            public string friendlyName
            {
                get
                {
                    fixed (FACTCueProperties* @this = &this)
                    {
                        var pointer = &@this->_friendlyName[0];
                        var cString = new CString(pointer);
                        return Runtime.CStrings.String(cString);
                    }
                }
            }

            [FieldOffset(256)] // size = 4, padding = 0
            public int interactive;

            [FieldOffset(260)] // size = 2, padding = 0
            public ushort iaVariableIndex;

            [FieldOffset(262)] // size = 2, padding = 0
            public ushort numVariations;

            [FieldOffset(264)] // size = 1, padding = 0
            public byte maxInstances;

            [FieldOffset(265)] // size = 1, padding = 2
            public byte currentInstances;
        }

        // Struct @ FACT.h:225:3
        [StructLayout(LayoutKind.Explicit, Size = 84, Pack = 4)]
        public struct FACTWaveProperties
        {
            [FieldOffset(0)] // size = 64, padding = 0
            public fixed byte _friendlyName[64 / 1]; // char[64]

            public string friendlyName
            {
                get
                {
                    fixed (FACTWaveProperties* @this = &this)
                    {
                        var pointer = &@this->_friendlyName[0];
                        var cString = new CString(pointer);
                        return Runtime.CStrings.String(cString);
                    }
                }
            }

            [FieldOffset(64)] // size = 4, padding = 0
            public FACTWaveBankMiniWaveFormat format;

            [FieldOffset(68)] // size = 4, padding = 0
            public uint durationInSamples;

            [FieldOffset(72)] // size = 8, padding = 0
            public FACTWaveBankSampleRegion loopRegion;

            [FieldOffset(80)] // size = 4, padding = 0
            public int streaming;
        }

        // Struct @ FACT.h:231:3
        [StructLayout(LayoutKind.Explicit, Size = 88, Pack = 4)]
        public struct FACTWaveInstanceProperties
        {
            [FieldOffset(0)] // size = 84, padding = 0
            public FACTWaveProperties properties;

            [FieldOffset(84)] // size = 4, padding = 0
            public int backgroundMusic;
        }

        // Struct @ FACT.h:282:3
        [StructLayout(LayoutKind.Explicit, Size = 316, Pack = 4)]
        public struct FACTCueInstanceProperties
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint allocAttributes;

            [FieldOffset(4)] // size = 268, padding = 0
            public FACTCueProperties cueProperties;

            [FieldOffset(272)] // size = 44, padding = 0
            public FACTSoundVariationProperties activeVariationProperties;
        }

        // Struct @ FAPOBase.h:97:25
        [StructLayout(LayoutKind.Explicit, Size = 224, Pack = 8)]
        public struct FAPOBase
        {
            [FieldOffset(0)] // size = 112, padding = 0
            public FAPO @base;

            [FieldOffset(112)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void Destructor;

            [FieldOffset(120)] // size = 8, padding = 0
            public OnSetParametersFunc OnSetParameters;

            [FieldOffset(128)] // size = 8, padding = 0
            public FAPORegistrationProperties* m_pRegistrationProperties;

            [FieldOffset(136)] // size = 8, padding = 0
            public void* m_pfnMatrixMixFunction;

            [FieldOffset(144)] // size = 8, padding = 0
            public float* m_pfl32MatrixCoefficients;

            [FieldOffset(152)] // size = 4, padding = 0
            public uint m_nSrcFormatType;

            [FieldOffset(156)] // size = 1, padding = 0
            public byte m_fIsScalarMatrix;

            [FieldOffset(157)] // size = 1, padding = 2
            public byte m_fIsLocked;

            [FieldOffset(160)] // size = 8, padding = 0
            public byte* m_pParameterBlocks;

            [FieldOffset(168)] // size = 8, padding = 0
            public byte* m_pCurrentParameters;

            [FieldOffset(176)] // size = 8, padding = 0
            public byte* m_pCurrentParametersInternal;

            [FieldOffset(184)] // size = 4, padding = 0
            public uint m_uCurrentParametersIndex;

            [FieldOffset(188)] // size = 4, padding = 0
            public uint m_uParameterBlockByteSize;

            [FieldOffset(192)] // size = 1, padding = 0
            public byte m_fNewerResultsReady;

            [FieldOffset(193)] // size = 1, padding = 2
            public byte m_fProducer;

            [FieldOffset(196)] // size = 4, padding = 0
            public int m_lReferenceCount;

            [FieldOffset(200)] // size = 8, padding = 0
            public FAudioMallocFunc pMalloc;

            [FieldOffset(208)] // size = 8, padding = 0
            public FAudioFreeFunc pFree;

            [FieldOffset(216)] // size = 8, padding = 0
            public FAudioReallocFunc pRealloc;
        }

        // Struct @ FAPO.h:75:3
        [StructLayout(LayoutKind.Explicit, Size = 1068, Pack = 1)]
        public struct FAPORegistrationProperties
        {
            [FieldOffset(0)] // size = 16, padding = 0
            public FAudioGUID clsid;

            [FieldOffset(16)] // size = 512, padding = 0
            public fixed ushort _FriendlyName[512 / 2]; // int16_t[256]

            public Span<short> FriendlyName
            {
                get
                {
                    fixed (FAPORegistrationProperties* @this = &this)
                    {
                        var pointer = &@this->_FriendlyName[0];
                        var span = new Span<short>(pointer, 256);
                        return span;
                    }
                }
            }

            [FieldOffset(528)] // size = 512, padding = 0
            public fixed ushort _CopyrightInfo[512 / 2]; // int16_t[256]

            public Span<short> CopyrightInfo
            {
                get
                {
                    fixed (FAPORegistrationProperties* @this = &this)
                    {
                        var pointer = &@this->_CopyrightInfo[0];
                        var span = new Span<short>(pointer, 256);
                        return span;
                    }
                }
            }

            [FieldOffset(1040)] // size = 4, padding = 0
            public uint MajorVersion;

            [FieldOffset(1044)] // size = 4, padding = 0
            public uint MinorVersion;

            [FieldOffset(1048)] // size = 4, padding = 0
            public uint Flags;

            [FieldOffset(1052)] // size = 4, padding = 0
            public uint MinInputBufferCount;

            [FieldOffset(1056)] // size = 4, padding = 0
            public uint MaxInputBufferCount;

            [FieldOffset(1060)] // size = 4, padding = 0
            public uint MinOutputBufferCount;

            [FieldOffset(1064)] // size = 4, padding = 0
            public uint MaxOutputBufferCount;
        }

        // Struct @ FAPO.h:81:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 1)]
        public struct FAPOLockForProcessBufferParameters
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public FAudioWaveFormatEx* pFormat;

            [FieldOffset(8)] // size = 4, padding = 0
            public uint MaxFrameCount;
        }

        // Struct @ FAudio.h:219:21
        [StructLayout(LayoutKind.Explicit, Size = 112, Pack = 8)]
        public struct FAPO
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public AddRefFunc AddRef;

            [FieldOffset(8)] // size = 8, padding = 0
            public ReleaseFunc Release;

            [FieldOffset(16)] // size = 8, padding = 0
            public GetRegistrationPropertiesFunc GetRegistrationProperties;

            [FieldOffset(24)] // size = 8, padding = 0
            public IsInputFormatSupportedFunc IsInputFormatSupported;

            [FieldOffset(32)] // size = 8, padding = 0
            public IsOutputFormatSupportedFunc IsOutputFormatSupported;

            [FieldOffset(40)] // size = 8, padding = 0
            public InitializeFunc Initialize;

            [FieldOffset(48)] // size = 8, padding = 0
            public ResetFunc Reset;

            [FieldOffset(56)] // size = 8, padding = 0
            public LockForProcessFunc LockForProcess;

            [FieldOffset(64)] // size = 8, padding = 0
            public UnlockForProcessFunc UnlockForProcess;

            [FieldOffset(72)] // size = 8, padding = 0
            public ProcessFunc Process;

            [FieldOffset(80)] // size = 8, padding = 0
            public CalcInputFramesFunc CalcInputFrames;

            [FieldOffset(88)] // size = 8, padding = 0
            public CalcOutputFramesFunc CalcOutputFrames;

            [FieldOffset(96)] // size = 8, padding = 0
            public SetParametersFunc SetParameters;

            [FieldOffset(104)] // size = 8, padding = 0
            public GetParametersFunc GetParameters;
        }

        // Struct @ FAudioFX.h:127:3
        [StructLayout(LayoutKind.Explicit, Size = 52, Pack = 1)]
        public struct FAudioFXReverbI3DL2Parameters
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public float WetDryMix;

            [FieldOffset(4)] // size = 4, padding = 0
            public int Room;

            [FieldOffset(8)] // size = 4, padding = 0
            public int RoomHF;

            [FieldOffset(12)] // size = 4, padding = 0
            public float RoomRolloffFactor;

            [FieldOffset(16)] // size = 4, padding = 0
            public float DecayTime;

            [FieldOffset(20)] // size = 4, padding = 0
            public float DecayHFRatio;

            [FieldOffset(24)] // size = 4, padding = 0
            public int Reflections;

            [FieldOffset(28)] // size = 4, padding = 0
            public float ReflectionsDelay;

            [FieldOffset(32)] // size = 4, padding = 0
            public int Reverb;

            [FieldOffset(36)] // size = 4, padding = 0
            public float ReverbDelay;

            [FieldOffset(40)] // size = 4, padding = 0
            public float Diffusion;

            [FieldOffset(44)] // size = 4, padding = 0
            public float Density;

            [FieldOffset(48)] // size = 4, padding = 0
            public float HFReference;
        }

        // Struct @ FAudioFX.h:83:3
        [StructLayout(LayoutKind.Explicit, Size = 52, Pack = 1)]
        public struct FAudioFXReverbParameters
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public float WetDryMix;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint ReflectionsDelay;

            [FieldOffset(8)] // size = 1, padding = 0
            public byte ReverbDelay;

            [FieldOffset(9)] // size = 1, padding = 0
            public byte RearDelay;

            [FieldOffset(10)] // size = 1, padding = 0
            public byte PositionLeft;

            [FieldOffset(11)] // size = 1, padding = 0
            public byte PositionRight;

            [FieldOffset(12)] // size = 1, padding = 0
            public byte PositionMatrixLeft;

            [FieldOffset(13)] // size = 1, padding = 0
            public byte PositionMatrixRight;

            [FieldOffset(14)] // size = 1, padding = 0
            public byte EarlyDiffusion;

            [FieldOffset(15)] // size = 1, padding = 0
            public byte LateDiffusion;

            [FieldOffset(16)] // size = 1, padding = 0
            public byte LowEQGain;

            [FieldOffset(17)] // size = 1, padding = 0
            public byte LowEQCutoff;

            [FieldOffset(18)] // size = 1, padding = 0
            public byte HighEQGain;

            [FieldOffset(19)] // size = 1, padding = 0
            public byte HighEQCutoff;

            [FieldOffset(20)] // size = 4, padding = 0
            public float RoomFilterFreq;

            [FieldOffset(24)] // size = 4, padding = 0
            public float RoomFilterMain;

            [FieldOffset(28)] // size = 4, padding = 0
            public float RoomFilterHF;

            [FieldOffset(32)] // size = 4, padding = 0
            public float ReflectionsGain;

            [FieldOffset(36)] // size = 4, padding = 0
            public float ReverbGain;

            [FieldOffset(40)] // size = 4, padding = 0
            public float DecayTime;

            [FieldOffset(44)] // size = 4, padding = 0
            public float Density;

            [FieldOffset(48)] // size = 4, padding = 0
            public float RoomSize;
        }

        // Struct @ FAudioFX.h:110:3
        [StructLayout(LayoutKind.Explicit, Size = 53, Pack = 1)]
        public struct FAudioFXReverbParameters9
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public float WetDryMix;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint ReflectionsDelay;

            [FieldOffset(8)] // size = 1, padding = 0
            public byte ReverbDelay;

            [FieldOffset(9)] // size = 1, padding = 0
            public byte RearDelay;

            [FieldOffset(10)] // size = 1, padding = 0
            public byte SideDelay;

            [FieldOffset(11)] // size = 1, padding = 0
            public byte PositionLeft;

            [FieldOffset(12)] // size = 1, padding = 0
            public byte PositionRight;

            [FieldOffset(13)] // size = 1, padding = 0
            public byte PositionMatrixLeft;

            [FieldOffset(14)] // size = 1, padding = 0
            public byte PositionMatrixRight;

            [FieldOffset(15)] // size = 1, padding = 0
            public byte EarlyDiffusion;

            [FieldOffset(16)] // size = 1, padding = 0
            public byte LateDiffusion;

            [FieldOffset(17)] // size = 1, padding = 0
            public byte LowEQGain;

            [FieldOffset(18)] // size = 1, padding = 0
            public byte LowEQCutoff;

            [FieldOffset(19)] // size = 1, padding = 0
            public byte HighEQGain;

            [FieldOffset(20)] // size = 1, padding = 0
            public byte HighEQCutoff;

            [FieldOffset(21)] // size = 4, padding = 0
            public float RoomFilterFreq;

            [FieldOffset(25)] // size = 4, padding = 0
            public float RoomFilterMain;

            [FieldOffset(29)] // size = 4, padding = 0
            public float RoomFilterHF;

            [FieldOffset(33)] // size = 4, padding = 0
            public float ReflectionsGain;

            [FieldOffset(37)] // size = 4, padding = 0
            public float ReverbGain;

            [FieldOffset(41)] // size = 4, padding = 0
            public float DecayTime;

            [FieldOffset(45)] // size = 4, padding = 0
            public float Density;

            [FieldOffset(49)] // size = 4, padding = 0
            public float RoomSize;
        }

        // Struct @ F3DAudio.h:155:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 1)]
        public struct F3DAUDIO_VECTOR
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public float x;

            [FieldOffset(4)] // size = 4, padding = 0
            public float y;

            [FieldOffset(8)] // size = 4, padding = 0
            public float z;
        }

        // Struct @ F3DAudio.h:179:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 1)]
        public struct F3DAUDIO_CONE
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public float InnerAngle;

            [FieldOffset(4)] // size = 4, padding = 0
            public float OuterAngle;

            [FieldOffset(8)] // size = 4, padding = 0
            public float InnerVolume;

            [FieldOffset(12)] // size = 4, padding = 0
            public float OuterVolume;

            [FieldOffset(16)] // size = 4, padding = 0
            public float InnerLPF;

            [FieldOffset(20)] // size = 4, padding = 0
            public float OuterLPF;

            [FieldOffset(24)] // size = 4, padding = 0
            public float InnerReverb;

            [FieldOffset(28)] // size = 4, padding = 0
            public float OuterReverb;
        }

        // Struct @ F3DAudio.h:167:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 1)]
        public struct F3DAUDIO_DISTANCE_CURVE
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public F3DAUDIO_DISTANCE_CURVE_POINT* pPoints;

            [FieldOffset(8)] // size = 4, padding = 0
            public uint PointCount;
        }

        // Struct @ FAudio.h:209:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 1)]
        public struct FAudioSendDescriptor
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint Flags;

            [FieldOffset(4)] // size = 8, padding = 0
            public FAudioVoice* pOutputVoice;
        }

        // Struct @ FAudio.h:227:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 1)]
        public struct FAudioEffectDescriptor
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public FAPO* pEffect;

            [FieldOffset(8)] // size = 4, padding = 0
            public int InitialState;

            [FieldOffset(12)] // size = 4, padding = 0
            public uint OutputChannels;
        }

        // Struct @ FACT.h:98:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct FACTFileIOCallbacks
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public FACTReadFileCallback readFileCallback;

            [FieldOffset(8)] // size = 8, padding = 0
            public FACTGetOverlappedResultCallback getOverlappedResultCallback;
        }

        // Struct @ FACT.h:180:3
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 1)]
        public struct FACTWaveBankMiniWaveFormat
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint dwValue;
        }

        // Struct @ FACT.h:153:3
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 1)]
        public struct FACTWaveBankRegion
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint dwOffset;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint dwLength;
        }

        // Struct @ FACT.h:159:3
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 1)]
        public struct FACTWaveBankSampleRegion
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint dwStartSample;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint dwTotalSamples;
        }

        // Struct @ FACT.h:275:3
        [StructLayout(LayoutKind.Explicit, Size = 44, Pack = 4)]
        public struct FACTSoundVariationProperties
        {
            [FieldOffset(0)] // size = 16, padding = 0
            public FACTVariationProperties variationProperties;

            [FieldOffset(16)] // size = 28, padding = 0
            public FACTSoundProperties soundProperties;
        }

        // Struct @ F3DAudio.h:161:3
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 1)]
        public struct F3DAUDIO_DISTANCE_CURVE_POINT
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public float Distance;

            [FieldOffset(4)] // size = 4, padding = 0
            public float DSPSetting;
        }

        // Struct @ FACT.h:54:33
        [StructLayout(LayoutKind.Explicit, Size = 49, Pack = 1)]
        public struct FACTNotification
        {
            [FieldOffset(0)] // size = 1, padding = 0
            public byte type;

            [FieldOffset(1)] // size = 4, padding = 0
            public int timeStamp;

            [FieldOffset(5)] // size = 8, padding = 36
            public void* pvContext;
        }

        // Struct @ FACT.h:259:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 4)]
        public struct FACTVariationProperties
        {
            [FieldOffset(0)] // size = 2, padding = 0
            public ushort index;

            [FieldOffset(2)] // size = 1, padding = 1
            public byte weight;

            [FieldOffset(4)] // size = 4, padding = 0
            public float iaVariableMin;

            [FieldOffset(8)] // size = 4, padding = 0
            public float iaVariableMax;

            [FieldOffset(12)] // size = 4, padding = 0
            public int linger;
        }

        // Struct @ FACT.h:269:3
        [StructLayout(LayoutKind.Explicit, Size = 28, Pack = 4)]
        public struct FACTSoundProperties
        {
            [FieldOffset(0)] // size = 2, padding = 0
            public ushort category;

            [FieldOffset(2)] // size = 1, padding = 1
            public byte priority;

            [FieldOffset(4)] // size = 2, padding = 2
            public short pitch;

            [FieldOffset(8)] // size = 4, padding = 0
            public float volume;

            [FieldOffset(12)] // size = 2, padding = 2
            public ushort numTracks;

            [FieldOffset(16)] // size = 12, padding = 0
            public fixed uint _arrTrackProperties[12 / 4]; // FACTTrackProperties[1]

            public Span<FACTTrackProperties> arrTrackProperties
            {
                get
                {
                    fixed (FACTSoundProperties* @this = &this)
                    {
                        var pointer = &@this->_arrTrackProperties[0];
                        var span = new Span<FACTTrackProperties>(pointer, 1);
                        return span;
                    }
                }
            }
        }

        // Struct @ FAPO.h:88:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 1)]
        public struct FAPOProcessBufferParameters
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* pBuffer;

            [FieldOffset(8)] // size = 4, padding = 0
            public FAPOBufferFlags BufferFlags;

            [FieldOffset(12)] // size = 4, padding = 0
            public uint ValidFrameCount;
        }

        // Struct @ FACT.h:77:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct FACTOverlapped
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* Internal;

            [FieldOffset(8)] // size = 8, padding = 8
            public void* InternalHigh;

            [FieldOffset(24)] // size = 8, padding = 0
            public void* hEvent;
        }

        // Struct @ FACT.h:250:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
        public struct FACTTrackProperties
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint duration;

            [FieldOffset(4)] // size = 2, padding = 0
            public ushort numVariations;

            [FieldOffset(6)] // size = 1, padding = 1
            public byte numChannels;

            [FieldOffset(8)] // size = 2, padding = 0
            public ushort waveVariation;

            [FieldOffset(10)] // size = 1, padding = 1
            public byte loopCount;
        }

        // OpaqueType @ FAudio.h:62:23
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioSystem
        {
        }

        // OpaqueType @ FAudio.h:64:21
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioSourceVoice
        {
        }

        // OpaqueType @ FAudio.h:65:21
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioSubmixVoice
        {
        }

        // OpaqueType @ FAudio.h:66:21
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioMasteringVoice
        {
        }

        // OpaqueType @ FAudio.h:63:28
        [StructLayout(LayoutKind.Sequential)]
        public struct FAudioVoice
        {
        }

        // OpaqueType @ FACT.h:49:32
        [StructLayout(LayoutKind.Sequential)]
        public struct FACTAudioEngine
        {
        }

        // OpaqueType @ FACT.h:50:30
        [StructLayout(LayoutKind.Sequential)]
        public struct FACTSoundBank
        {
        }

        // OpaqueType @ FACT.h:51:29
        [StructLayout(LayoutKind.Sequential)]
        public struct FACTWaveBank
        {
        }

        // OpaqueType @ FACT.h:52:25
        [StructLayout(LayoutKind.Sequential)]
        public struct FACTWave
        {
        }

        // OpaqueType @ FACT.h:53:24
        [StructLayout(LayoutKind.Sequential)]
        public struct FACTCue
        {
        }

        // Typedef @ F3DAudio.h:144:17
        [StructLayout(LayoutKind.Explicit, Size = 20, Pack = 1)]
        public struct F3DAUDIO_HANDLE
        {
            [FieldOffset(0)] // size = 20, padding = 0
            public byte* Data;

            public static implicit operator byte*(F3DAUDIO_HANDLE data) => data.Data;
            public static implicit operator F3DAUDIO_HANDLE(byte* data) => new() { Data = data };
        }

        // Typedef @ FAudio.h:108:18
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct FAudioProcessor
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint Data;

            public static implicit operator uint(FAudioProcessor data) => data.Data;
            public static implicit operator FAudioProcessor(uint data) => new() { Data = data };
        }

        // Enum @ FAudio.h:105:3
        public enum FAudioStreamCategory : int
        {
            FAudioStreamCategory_Other = 0,
            FAudioStreamCategory_ForegroundOnlyMedia = 1,
            FAudioStreamCategory_BackgroundCapableMedia = 2,
            FAudioStreamCategory_Communications = 3,
            FAudioStreamCategory_Alerts = 4,
            FAudioStreamCategory_SoundEffects = 5,
            FAudioStreamCategory_GameEffects = 6,
            FAudioStreamCategory_GameMedia = 7,
            FAudioStreamCategory_GameChat = 8,
            FAudioStreamCategory_Speech = 9,
            FAudioStreamCategory_Movie = 10,
            FAudioStreamCategory_Media = 11
        }

        // Enum @ FAudio.h:81:3
        public enum FAudioDeviceRole : int
        {
            FAudioNotDefaultDevice = 0,
            FAudioDefaultConsoleDevice = 1,
            FAudioDefaultMultimediaDevice = 2,
            FAudioDefaultCommunicationsDevice = 4,
            FAudioDefaultGameDevice = 8,
            FAudioGlobalDefaultDevice = 15,
            FAudioInvalidDeviceRole = -16
        }

        // Enum @ FAudio.h:89:3
        public enum FAudioFilterType : int
        {
            FAudioLowPassFilter = 0,
            FAudioBandPassFilter = 1,
            FAudioHighPassFilter = 2,
            FAudioNotchFilter = 3
        }

        // Enum @ FAPO.h:57:3
        public enum FAPOBufferFlags : int
        {
            FAPO_BUFFER_SILENT = 0,
            FAPO_BUFFER_VALID = 1
        }

        // Pseudo enum 'FACTWaveBankSegIdx' @ FACT.h:137:14
        public const int FACT_WAVEBANK_SEGIDX_BANKDATA = 0;
        public const int FACT_WAVEBANK_SEGIDX_ENTRYMETADATA = 1;
        public const int FACT_WAVEBANK_SEGIDX_SEEKTABLES = 2;
        public const int FACT_WAVEBANK_SEGIDX_ENTRYNAMES = 3;
        public const int FACT_WAVEBANK_SEGIDX_ENTRYWAVEDATA = 4;
        public const int FACT_WAVEBANK_SEGIDX_COUNT = 5;

        // MacroDefinition @ F3DAudio.h:49:9
        public const int SPEAKER_FRONT_LEFT = 0x00000001;

        // MacroDefinition @ F3DAudio.h:50:9
        public const int SPEAKER_FRONT_RIGHT = 0x00000002;

        // MacroDefinition @ F3DAudio.h:51:9
        public const int SPEAKER_FRONT_CENTER = 0x00000004;

        // MacroDefinition @ F3DAudio.h:52:9
        public const int SPEAKER_LOW_FREQUENCY = 0x00000008;

        // MacroDefinition @ F3DAudio.h:53:9
        public const int SPEAKER_BACK_LEFT = 0x00000010;

        // MacroDefinition @ F3DAudio.h:54:9
        public const int SPEAKER_BACK_RIGHT = 0x00000020;

        // MacroDefinition @ F3DAudio.h:55:9
        public const int SPEAKER_FRONT_LEFT_OF_CENTER = 0x00000040;

        // MacroDefinition @ F3DAudio.h:56:9
        public const int SPEAKER_FRONT_RIGHT_OF_CENTER = 0x00000080;

        // MacroDefinition @ F3DAudio.h:57:9
        public const int SPEAKER_BACK_CENTER = 0x00000100;

        // MacroDefinition @ F3DAudio.h:58:9
        public const int SPEAKER_SIDE_LEFT = 0x00000200;

        // MacroDefinition @ F3DAudio.h:59:9
        public const int SPEAKER_SIDE_RIGHT = 0x00000400;

        // MacroDefinition @ F3DAudio.h:60:9
        public const int SPEAKER_TOP_CENTER = 0x00000800;

        // MacroDefinition @ F3DAudio.h:61:9
        public const int SPEAKER_TOP_FRONT_LEFT = 0x00001000;

        // MacroDefinition @ F3DAudio.h:62:9
        public const int SPEAKER_TOP_FRONT_CENTER = 0x00002000;

        // MacroDefinition @ F3DAudio.h:63:9
        public const int SPEAKER_TOP_FRONT_RIGHT = 0x00004000;

        // MacroDefinition @ F3DAudio.h:64:9
        public const int SPEAKER_TOP_BACK_LEFT = 0x00008000;

        // MacroDefinition @ F3DAudio.h:65:9
        public const int SPEAKER_TOP_BACK_CENTER = 0x00010000;

        // MacroDefinition @ F3DAudio.h:66:9
        public const int SPEAKER_TOP_BACK_RIGHT = 0x00020000;

        // MacroDefinition @ F3DAudio.h:71:9
        public const int SPEAKER_MONO = SPEAKER_FRONT_CENTER;

        // MacroDefinition @ F3DAudio.h:72:9
        public const int SPEAKER_STEREO = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;

        // MacroDefinition @ F3DAudio.h:73:9
        public const int SPEAKER_2POINT1 = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_LOW_FREQUENCY;

        // MacroDefinition @ F3DAudio.h:77:9
        public const int SPEAKER_SURROUND = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER;

        // MacroDefinition @ F3DAudio.h:82:9
        public const int SPEAKER_QUAD = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT;

        // MacroDefinition @ F3DAudio.h:87:9
        public const int SPEAKER_4POINT1 = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT;

        // MacroDefinition @ F3DAudio.h:93:9
        public const int SPEAKER_5POINT1 = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT;

        // MacroDefinition @ F3DAudio.h:100:9
        public const int SPEAKER_7POINT1 = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER;

        // MacroDefinition @ F3DAudio.h:109:9
        public const int SPEAKER_5POINT1_SURROUND = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT;

        // MacroDefinition @ F3DAudio.h:116:9
        public const int SPEAKER_7POINT1_SURROUND = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT;

        // MacroDefinition @ F3DAudio.h:128:9
        public const float F3DAUDIO_PI = 3.141592654f;

        // MacroDefinition @ F3DAudio.h:129:9
        public const float F3DAUDIO_2PI = 6.283185307f;

        // MacroDefinition @ F3DAudio.h:131:9
        public const int F3DAUDIO_CALCULATE_MATRIX = 0x00000001;

        // MacroDefinition @ F3DAudio.h:132:9
        public const int F3DAUDIO_CALCULATE_DELAY = 0x00000002;

        // MacroDefinition @ F3DAudio.h:133:9
        public const int F3DAUDIO_CALCULATE_LPF_DIRECT = 0x00000004;

        // MacroDefinition @ F3DAudio.h:134:9
        public const int F3DAUDIO_CALCULATE_LPF_REVERB = 0x00000008;

        // MacroDefinition @ F3DAudio.h:135:9
        public const int F3DAUDIO_CALCULATE_REVERB = 0x00000010;

        // MacroDefinition @ F3DAudio.h:136:9
        public const int F3DAUDIO_CALCULATE_DOPPLER = 0x00000020;

        // MacroDefinition @ F3DAudio.h:137:9
        public const int F3DAUDIO_CALCULATE_EMITTER_ANGLE = 0x00000040;

        // MacroDefinition @ F3DAudio.h:138:9
        public const int F3DAUDIO_CALCULATE_ZEROCENTER = 0x00010000;

        // MacroDefinition @ F3DAudio.h:139:9
        public const int F3DAUDIO_CALCULATE_REDIRECT_TO_LFE = 0x00020000;

        // MacroDefinition @ F3DAudio.h:143:9
        public const int F3DAUDIO_HANDLE_BYTESIZE = 20;

        // MacroDefinition @ FAudio.h:109:9
        public const uint FAUDIO_DEFAULT_PROCESSOR = 0xFFFFFFFF;

        // MacroDefinition @ FAudio.h:336:9
        public const uint FAUDIO_E_OUT_OF_MEMORY = 0x8007000e;

        // MacroDefinition @ FAudio.h:337:9
        public const uint FAUDIO_E_INVALID_ARG = 0x80070057;

        // MacroDefinition @ FAudio.h:338:9
        public const uint FAUDIO_E_UNSUPPORTED_FORMAT = 0x88890008;

        // MacroDefinition @ FAudio.h:339:9
        public const uint FAUDIO_E_INVALID_CALL = 0x88960001;

        // MacroDefinition @ FAudio.h:340:9
        public const uint FAUDIO_E_DEVICE_INVALIDATED = 0x88960004;

        // MacroDefinition @ FAudio.h:341:9
        public const uint FAPO_E_FORMAT_UNSUPPORTED = 0x88970001;

        // MacroDefinition @ FAudio.h:343:9
        public const uint FAUDIO_MAX_BUFFER_BYTES = 0x80000000;

        // MacroDefinition @ FAudio.h:344:9
        public const int FAUDIO_MAX_QUEUED_BUFFERS = 64;

        // MacroDefinition @ FAudio.h:345:9
        public const int FAUDIO_MAX_AUDIO_CHANNELS = 64;

        // MacroDefinition @ FAudio.h:346:9
        public const int FAUDIO_MIN_SAMPLE_RATE = 1000;

        // MacroDefinition @ FAudio.h:347:9
        public const int FAUDIO_MAX_SAMPLE_RATE = 200000;

        // MacroDefinition @ FAudio.h:348:9
        public const float FAUDIO_MAX_VOLUME_LEVEL = 16777216.0f;

        // MacroDefinition @ FAudio.h:349:9
        public const float FAUDIO_MIN_FREQ_RATIO = 1.0f / 1024.0f;

        // MacroDefinition @ FAudio.h:350:9
        public const float FAUDIO_MAX_FREQ_RATIO = 1024.0f;

        // MacroDefinition @ FAudio.h:351:9
        public const float FAUDIO_DEFAULT_FREQ_RATIO = 2.0f;

        // MacroDefinition @ FAudio.h:352:9
        public const float FAUDIO_MAX_FILTER_ONEOVERQ = 1.5f;

        // MacroDefinition @ FAudio.h:353:9
        public const float FAUDIO_MAX_FILTER_FREQUENCY = 1.0f;

        // MacroDefinition @ FAudio.h:354:9
        public const int FAUDIO_MAX_LOOP_COUNT = 254;

        // MacroDefinition @ FAudio.h:356:9
        public const int FAUDIO_COMMIT_NOW = 0;

        // MacroDefinition @ FAudio.h:357:9
        public const int FAUDIO_COMMIT_ALL = 0;

        // MacroDefinition @ FAudio.h:359:9
        public const int FAUDIO_NO_LOOP_REGION = 0;

        // MacroDefinition @ FAudio.h:360:9
        public const int FAUDIO_LOOP_INFINITE = 255;

        // MacroDefinition @ FAudio.h:361:9
        public const int FAUDIO_DEFAULT_CHANNELS = 0;

        // MacroDefinition @ FAudio.h:362:9
        public const int FAUDIO_DEFAULT_SAMPLERATE = 0;

        // MacroDefinition @ FAudio.h:364:9
        public const int FAUDIO_DEBUG_ENGINE = 0x0001;

        // MacroDefinition @ FAudio.h:365:9
        public const int FAUDIO_VOICE_NOPITCH = 0x0002;

        // MacroDefinition @ FAudio.h:366:9
        public const int FAUDIO_VOICE_NOSRC = 0x0004;

        // MacroDefinition @ FAudio.h:367:9
        public const int FAUDIO_VOICE_USEFILTER = 0x0008;

        // MacroDefinition @ FAudio.h:368:9
        public const int FAUDIO_VOICE_MUSIC = 0x0010;

        // MacroDefinition @ FAudio.h:369:9
        public const int FAUDIO_PLAY_TAILS = 0x0020;

        // MacroDefinition @ FAudio.h:370:9
        public const int FAUDIO_END_OF_STREAM = 0x0040;

        // MacroDefinition @ FAudio.h:371:9
        public const int FAUDIO_SEND_USEFILTER = 0x0080;

        // MacroDefinition @ FAudio.h:372:9
        public const int FAUDIO_VOICE_NOSAMPLESPLAYED = 0x0100;

        // MacroDefinition @ FAudio.h:373:9
        public const int FAUDIO_1024_QUANTUM = 0x8000;

        // MacroDefinition @ FAudio.h:376:9
        public const float FAUDIO_DEFAULT_FILTER_FREQUENCY = FAUDIO_MAX_FILTER_FREQUENCY;

        // MacroDefinition @ FAudio.h:377:9
        public const float FAUDIO_DEFAULT_FILTER_ONEOVERQ = 1.0f;

        // MacroDefinition @ FAudio.h:379:9
        public const int FAUDIO_LOG_ERRORS = 0x0001;

        // MacroDefinition @ FAudio.h:380:9
        public const int FAUDIO_LOG_WARNINGS = 0x0002;

        // MacroDefinition @ FAudio.h:381:9
        public const int FAUDIO_LOG_INFO = 0x0004;

        // MacroDefinition @ FAudio.h:382:9
        public const int FAUDIO_LOG_DETAIL = 0x0008;

        // MacroDefinition @ FAudio.h:383:9
        public const int FAUDIO_LOG_API_CALLS = 0x0010;

        // MacroDefinition @ FAudio.h:384:9
        public const int FAUDIO_LOG_FUNC_CALLS = 0x0020;

        // MacroDefinition @ FAudio.h:385:9
        public const int FAUDIO_LOG_TIMING = 0x0040;

        // MacroDefinition @ FAudio.h:386:9
        public const int FAUDIO_LOG_LOCKS = 0x0080;

        // MacroDefinition @ FAudio.h:387:9
        public const int FAUDIO_LOG_MEMORY = 0x0100;

        // MacroDefinition @ FAudio.h:388:9
        public const int FAUDIO_LOG_STREAMING = 0x1000;

        // MacroDefinition @ FAudio.h:470:9
        public const int FAUDIO_FORMAT_PCM = 1;

        // MacroDefinition @ FAudio.h:471:9
        public const int FAUDIO_FORMAT_MSADPCM = 2;

        // MacroDefinition @ FAudio.h:472:9
        public const int FAUDIO_FORMAT_IEEE_FLOAT = 3;

        // MacroDefinition @ FAudio.h:473:9
        public const int FAUDIO_FORMAT_WMAUDIO2 = 0x0161;

        // MacroDefinition @ FAudio.h:474:9
        public const int FAUDIO_FORMAT_WMAUDIO3 = 0x0162;

        // MacroDefinition @ FAudio.h:475:9
        public const int FAUDIO_FORMAT_WMAUDIO_LOSSLESS = 0x0163;

        // MacroDefinition @ FAudio.h:476:9
        public const int FAUDIO_FORMAT_XMAUDIO2 = 0x0166;

        // MacroDefinition @ FAudio.h:477:9
        public const int FAUDIO_FORMAT_EXTENSIBLE = 0xFFFE;

        // MacroDefinition @ FAudio.h:484:9
        public const int FAUDIO_TARGET_VERSION = 8;

        // MacroDefinition @ FAudio.h:486:9
        public const int FAUDIO_ABI_VERSION = 0;

        // MacroDefinition @ FAudio.h:487:9
        public const int FAUDIO_MAJOR_VERSION = 22;

        // MacroDefinition @ FAudio.h:488:9
        public const int FAUDIO_MINOR_VERSION = 4;

        // MacroDefinition @ FAudio.h:489:9
        public const int FAUDIO_PATCH_VERSION = 0;

        // MacroDefinition @ FAudio.h:491:9
        public const int FAUDIO_COMPILED_VERSION = (FAUDIO_ABI_VERSION * 100 * 100 * 100) + (FAUDIO_MAJOR_VERSION * 100 * 100) + (FAUDIO_MINOR_VERSION * 100) + (FAUDIO_PATCH_VERSION);

        // MacroDefinition @ FAudio.h:1282:9
        public const int FAUDIO_SEEK_SET = 0;

        // MacroDefinition @ FAudio.h:1283:9
        public const int FAUDIO_SEEK_CUR = 1;

        // MacroDefinition @ FAudio.h:1284:9
        public const int FAUDIO_SEEK_END = 2;

        // MacroDefinition @ FAudio.h:1285:9
        public const int FAUDIO_EOF = -1;

        // MacroDefinition @ FACT.h:127:9
        public const int FACT_WAVEBANK_TYPE_BUFFER = 0x00000000;

        // MacroDefinition @ FACT.h:128:9
        public const int FACT_WAVEBANK_TYPE_STREAMING = 0x00000001;

        // MacroDefinition @ FACT.h:129:9
        public const int FACT_WAVEBANK_TYPE_MASK = 0x00000001;

        // MacroDefinition @ FACT.h:131:9
        public const int FACT_WAVEBANK_FLAGS_ENTRYNAMES = 0x00010000;

        // MacroDefinition @ FACT.h:132:9
        public const int FACT_WAVEBANK_FLAGS_COMPACT = 0x00020000;

        // MacroDefinition @ FACT.h:133:9
        public const int FACT_WAVEBANK_FLAGS_SYNC_DISABLED = 0x00040000;

        // MacroDefinition @ FACT.h:134:9
        public const int FACT_WAVEBANK_FLAGS_SEEKTABLES = 0x00080000;

        // MacroDefinition @ FACT.h:135:9
        public const int FACT_WAVEBANK_FLAGS_MASK = 0x000F0000;

        // MacroDefinition @ FACT.h:370:9
        public const int FACT_CONTENT_VERSION = 46;

        // MacroDefinition @ FACT.h:424:9
        public const int FACT_ENGINE_LOOKAHEAD_DEFAULT = 250;

        // MacroDefinition @ FACT.h:426:9
        public const int FACT_MAX_WMA_AVG_BYTES_PER_SEC_ENTRIES = 7;

        // MacroDefinition @ FACT.h:438:9
        public const int FACT_MAX_WMA_BLOCK_ALIGN_ENTRIES = 17;

        // MacroDefinition @ FACT3D.h:43:9
        public const float LEFT_AZIMUTH = 3.0f * F3DAUDIO_PI / 2.0f;

        // MacroDefinition @ FACT3D.h:44:9
        public const float RIGHT_AZIMUTH = F3DAUDIO_PI / 2.0f;

        // MacroDefinition @ FACT3D.h:45:9
        public const float FRONT_LEFT_AZIMUTH = 7.0f * F3DAUDIO_PI / 4.0f;

        // MacroDefinition @ FACT3D.h:46:9
        public const float FRONT_RIGHT_AZIMUTH = F3DAUDIO_PI / 4.0f;

        // MacroDefinition @ FACT3D.h:47:9
        public const float FRONT_CENTER_AZIMUTH = 0.0f;

        // MacroDefinition @ FACT3D.h:48:9
        public const float LOW_FREQUENCY_AZIMUTH = F3DAUDIO_2PI;

        // MacroDefinition @ FACT3D.h:49:9
        public const float BACK_LEFT_AZIMUTH = 5.0f * F3DAUDIO_PI / 4.0f;

        // MacroDefinition @ FACT3D.h:50:9
        public const float BACK_RIGHT_AZIMUTH = 3.0f * F3DAUDIO_PI / 4.0f;

        // MacroDefinition @ FACT3D.h:51:9
        public const float BACK_CENTER_AZIMUTH = F3DAUDIO_PI;

        // MacroDefinition @ FACT3D.h:52:9
        public const float FRONT_LEFT_OF_CENTER_AZIMUTH = 15.0f * F3DAUDIO_PI / 8.0f;

        // MacroDefinition @ FACT3D.h:53:9
        public const float FRONT_RIGHT_OF_CENTER_AZIMUTH = F3DAUDIO_PI / 8.0f;

        // MacroDefinition @ FAPO.h:94:9
        public const int FAPO_MIN_CHANNELS = 1;

        // MacroDefinition @ FAPO.h:95:9
        public const int FAPO_MAX_CHANNELS = 64;

        // MacroDefinition @ FAPO.h:97:9
        public const int FAPO_MIN_FRAMERATE = 1000;

        // MacroDefinition @ FAPO.h:98:9
        public const int FAPO_MAX_FRAMERATE = 200000;

        // MacroDefinition @ FAPO.h:100:9
        public const int FAPO_REGISTRATION_STRING_LENGTH = 256;

        // MacroDefinition @ FAPO.h:102:9
        public const int FAPO_FLAG_CHANNELS_MUST_MATCH = 0x00000001;

        // MacroDefinition @ FAPO.h:103:9
        public const int FAPO_FLAG_FRAMERATE_MUST_MATCH = 0x00000002;

        // MacroDefinition @ FAPO.h:104:9
        public const int FAPO_FLAG_BITSPERSAMPLE_MUST_MATCH = 0x00000004;

        // MacroDefinition @ FAPO.h:105:9
        public const int FAPO_FLAG_BUFFERCOUNT_MUST_MATCH = 0x00000008;

        // MacroDefinition @ FAPO.h:106:9
        public const int FAPO_FLAG_INPLACE_REQUIRED = 0x00000020;

        // MacroDefinition @ FAPO.h:107:9
        public const int FAPO_FLAG_INPLACE_SUPPORTED = 0x00000010;

        // MacroDefinition @ FAPOBase.h:78:9
        public const int FAPOBASE_DEFAULT_FORMAT_TAG = FAUDIO_FORMAT_IEEE_FLOAT;

        // MacroDefinition @ FAPOBase.h:79:9
        public const int FAPOBASE_DEFAULT_FORMAT_MIN_CHANNELS = FAPO_MIN_CHANNELS;

        // MacroDefinition @ FAPOBase.h:80:9
        public const int FAPOBASE_DEFAULT_FORMAT_MAX_CHANNELS = FAPO_MAX_CHANNELS;

        // MacroDefinition @ FAPOBase.h:81:9
        public const int FAPOBASE_DEFAULT_FORMAT_MIN_FRAMERATE = FAPO_MIN_FRAMERATE;

        // MacroDefinition @ FAPOBase.h:82:9
        public const int FAPOBASE_DEFAULT_FORMAT_MAX_FRAMERATE = FAPO_MAX_FRAMERATE;

        // MacroDefinition @ FAPOBase.h:83:9
        public const int FAPOBASE_DEFAULT_FORMAT_BITSPERSAMPLE = 32;

        // MacroDefinition @ FAPOBase.h:85:9
        public const int FAPOBASE_DEFAULT_FLAG = FAPO_FLAG_CHANNELS_MUST_MATCH | FAPO_FLAG_FRAMERATE_MUST_MATCH | FAPO_FLAG_BITSPERSAMPLE_MUST_MATCH | FAPO_FLAG_BUFFERCOUNT_MUST_MATCH | FAPO_FLAG_INPLACE_SUPPORTED;

        // MacroDefinition @ FAPOBase.h:93:9
        public const int FAPOBASE_DEFAULT_BUFFER_COUNT = 1;

        // MacroDefinition @ FAPOFX.h:97:9
        public const int FAPOFXEQ_MIN_FRAMERATE = 22000;

        // MacroDefinition @ FAPOFX.h:98:9
        public const int FAPOFXEQ_MAX_FRAMERATE = 48000;

        // MacroDefinition @ FAPOFX.h:100:9
        public const float FAPOFXEQ_MIN_FREQUENCY_CENTER = 20.0f;

        // MacroDefinition @ FAPOFX.h:101:9
        public const float FAPOFXEQ_MAX_FREQUENCY_CENTER = 20000.0f;

        // MacroDefinition @ FAPOFX.h:102:9
        public const float FAPOFXEQ_DEFAULT_FREQUENCY_CENTER_0 = 100.0f;

        // MacroDefinition @ FAPOFX.h:103:9
        public const float FAPOFXEQ_DEFAULT_FREQUENCY_CENTER_1 = 800.0f;

        // MacroDefinition @ FAPOFX.h:104:9
        public const float FAPOFXEQ_DEFAULT_FREQUENCY_CENTER_2 = 2000.0f;

        // MacroDefinition @ FAPOFX.h:105:9
        public const float FAPOFXEQ_DEFAULT_FREQUENCY_CENTER_3 = 10000.0f;

        // MacroDefinition @ FAPOFX.h:107:9
        public const float FAPOFXEQ_MIN_GAIN = 0.126f;

        // MacroDefinition @ FAPOFX.h:108:9
        public const float FAPOFXEQ_MAX_GAIN = 7.94f;

        // MacroDefinition @ FAPOFX.h:109:9
        public const float FAPOFXEQ_DEFAULT_GAIN = 1.0f;

        // MacroDefinition @ FAPOFX.h:111:9
        public const float FAPOFXEQ_MIN_BANDWIDTH = 0.1f;

        // MacroDefinition @ FAPOFX.h:112:9
        public const float FAPOFXEQ_MAX_BANDWIDTH = 2.0f;

        // MacroDefinition @ FAPOFX.h:113:9
        public const float FAPOFXEQ_DEFAULT_BANDWIDTH = 1.0f;

        // MacroDefinition @ FAPOFX.h:115:9
        public const int FAPOFXMASTERINGLIMITER_MIN_RELEASE = 1;

        // MacroDefinition @ FAPOFX.h:116:9
        public const int FAPOFXMASTERINGLIMITER_MAX_RELEASE = 20;

        // MacroDefinition @ FAPOFX.h:117:9
        public const int FAPOFXMASTERINGLIMITER_DEFAULT_RELEASE = 6;

        // MacroDefinition @ FAPOFX.h:119:9
        public const int FAPOFXMASTERINGLIMITER_MIN_LOUDNESS = 1;

        // MacroDefinition @ FAPOFX.h:120:9
        public const int FAPOFXMASTERINGLIMITER_MAX_LOUDNESS = 1800;

        // MacroDefinition @ FAPOFX.h:121:9
        public const int FAPOFXMASTERINGLIMITER_DEFAULT_LOUDNESS = 1000;

        // MacroDefinition @ FAPOFX.h:123:9
        public const float FAPOFXREVERB_MIN_DIFFUSION = 0.0f;

        // MacroDefinition @ FAPOFX.h:124:9
        public const float FAPOFXREVERB_MAX_DIFFUSION = 1.0f;

        // MacroDefinition @ FAPOFX.h:125:9
        public const float FAPOFXREVERB_DEFAULT_DIFFUSION = 0.9f;

        // MacroDefinition @ FAPOFX.h:127:9
        public const float FAPOFXREVERB_MIN_ROOMSIZE = 0.0001f;

        // MacroDefinition @ FAPOFX.h:128:9
        public const float FAPOFXREVERB_MAX_ROOMSIZE = 1.0f;

        // MacroDefinition @ FAPOFX.h:129:9
        public const float FAPOFXREVERB_DEFAULT_ROOMSIZE = 0.6f;

        // MacroDefinition @ FAPOFX.h:131:9
        public const float FAPOFXECHO_MIN_WETDRYMIX = 0.0f;

        // MacroDefinition @ FAPOFX.h:132:9
        public const float FAPOFXECHO_MAX_WETDRYMIX = 1.0f;

        // MacroDefinition @ FAPOFX.h:133:9
        public const float FAPOFXECHO_DEFAULT_WETDRYMIX = 0.5f;

        // MacroDefinition @ FAPOFX.h:135:9
        public const float FAPOFXECHO_MIN_FEEDBACK = 0.0f;

        // MacroDefinition @ FAPOFX.h:136:9
        public const float FAPOFXECHO_MAX_FEEDBACK = 1.0f;

        // MacroDefinition @ FAPOFX.h:137:9
        public const float FAPOFXECHO_DEFAULT_FEEDBACK = 0.5f;

        // MacroDefinition @ FAPOFX.h:139:9
        public const float FAPOFXECHO_MIN_DELAY = 1.0f;

        // MacroDefinition @ FAPOFX.h:140:9
        public const float FAPOFXECHO_MAX_DELAY = 2000.0f;

        // MacroDefinition @ FAPOFX.h:141:9
        public const float FAPOFXECHO_DEFAULT_DELAY = 500.0f;

        // MacroDefinition @ FAudioFX.h:133:9
        public const int FAUDIOFX_DEBUG = 1;

        // MacroDefinition @ FAudioFX.h:135:9
        public const int FAUDIOFX_REVERB_MIN_FRAMERATE = 20000;

        // MacroDefinition @ FAudioFX.h:136:9
        public const int FAUDIOFX_REVERB_MAX_FRAMERATE = 48000;

        // MacroDefinition @ FAudioFX.h:138:9
        public const float FAUDIOFX_REVERB_MIN_WET_DRY_MIX = 0.0f;

        // MacroDefinition @ FAudioFX.h:139:9
        public const int FAUDIOFX_REVERB_MIN_REFLECTIONS_DELAY = 0;

        // MacroDefinition @ FAudioFX.h:140:9
        public const int FAUDIOFX_REVERB_MIN_REVERB_DELAY = 0;

        // MacroDefinition @ FAudioFX.h:141:9
        public const int FAUDIOFX_REVERB_MIN_REAR_DELAY = 0;

        // MacroDefinition @ FAudioFX.h:142:9
        public const int FAUDIOFX_REVERB_MIN_7POINT1_SIDE_DELAY = 0;

        // MacroDefinition @ FAudioFX.h:143:9
        public const int FAUDIOFX_REVERB_MIN_7POINT1_REAR_DELAY = 0;

        // MacroDefinition @ FAudioFX.h:144:9
        public const int FAUDIOFX_REVERB_MIN_POSITION = 0;

        // MacroDefinition @ FAudioFX.h:145:9
        public const int FAUDIOFX_REVERB_MIN_DIFFUSION = 0;

        // MacroDefinition @ FAudioFX.h:146:9
        public const int FAUDIOFX_REVERB_MIN_LOW_EQ_GAIN = 0;

        // MacroDefinition @ FAudioFX.h:147:9
        public const int FAUDIOFX_REVERB_MIN_LOW_EQ_CUTOFF = 0;

        // MacroDefinition @ FAudioFX.h:148:9
        public const int FAUDIOFX_REVERB_MIN_HIGH_EQ_GAIN = 0;

        // MacroDefinition @ FAudioFX.h:149:9
        public const int FAUDIOFX_REVERB_MIN_HIGH_EQ_CUTOFF = 0;

        // MacroDefinition @ FAudioFX.h:150:9
        public const float FAUDIOFX_REVERB_MIN_ROOM_FILTER_FREQ = 20.0f;

        // MacroDefinition @ FAudioFX.h:151:9
        public const float FAUDIOFX_REVERB_MIN_ROOM_FILTER_MAIN = -100.0f;

        // MacroDefinition @ FAudioFX.h:152:9
        public const float FAUDIOFX_REVERB_MIN_ROOM_FILTER_HF = -100.0f;

        // MacroDefinition @ FAudioFX.h:153:9
        public const float FAUDIOFX_REVERB_MIN_REFLECTIONS_GAIN = -100.0f;

        // MacroDefinition @ FAudioFX.h:154:9
        public const float FAUDIOFX_REVERB_MIN_REVERB_GAIN = -100.0f;

        // MacroDefinition @ FAudioFX.h:155:9
        public const float FAUDIOFX_REVERB_MIN_DECAY_TIME = 0.1f;

        // MacroDefinition @ FAudioFX.h:156:9
        public const float FAUDIOFX_REVERB_MIN_DENSITY = 0.0f;

        // MacroDefinition @ FAudioFX.h:157:9
        public const float FAUDIOFX_REVERB_MIN_ROOM_SIZE = 0.0f;

        // MacroDefinition @ FAudioFX.h:159:9
        public const float FAUDIOFX_REVERB_MAX_WET_DRY_MIX = 100.0f;

        // MacroDefinition @ FAudioFX.h:160:9
        public const int FAUDIOFX_REVERB_MAX_REFLECTIONS_DELAY = 300;

        // MacroDefinition @ FAudioFX.h:161:9
        public const int FAUDIOFX_REVERB_MAX_REVERB_DELAY = 85;

        // MacroDefinition @ FAudioFX.h:162:9
        public const int FAUDIOFX_REVERB_MAX_REAR_DELAY = 5;

        // MacroDefinition @ FAudioFX.h:163:9
        public const int FAUDIOFX_REVERB_MAX_7POINT1_SIDE_DELAY = 5;

        // MacroDefinition @ FAudioFX.h:164:9
        public const int FAUDIOFX_REVERB_MAX_7POINT1_REAR_DELAY = 20;

        // MacroDefinition @ FAudioFX.h:165:9
        public const int FAUDIOFX_REVERB_MAX_POSITION = 30;

        // MacroDefinition @ FAudioFX.h:166:9
        public const int FAUDIOFX_REVERB_MAX_DIFFUSION = 15;

        // MacroDefinition @ FAudioFX.h:167:9
        public const int FAUDIOFX_REVERB_MAX_LOW_EQ_GAIN = 12;

        // MacroDefinition @ FAudioFX.h:168:9
        public const int FAUDIOFX_REVERB_MAX_LOW_EQ_CUTOFF = 9;

        // MacroDefinition @ FAudioFX.h:169:9
        public const int FAUDIOFX_REVERB_MAX_HIGH_EQ_GAIN = 8;

        // MacroDefinition @ FAudioFX.h:170:9
        public const int FAUDIOFX_REVERB_MAX_HIGH_EQ_CUTOFF = 14;

        // MacroDefinition @ FAudioFX.h:171:9
        public const float FAUDIOFX_REVERB_MAX_ROOM_FILTER_FREQ = 20000.0f;

        // MacroDefinition @ FAudioFX.h:172:9
        public const float FAUDIOFX_REVERB_MAX_ROOM_FILTER_MAIN = 0.0f;

        // MacroDefinition @ FAudioFX.h:173:9
        public const float FAUDIOFX_REVERB_MAX_ROOM_FILTER_HF = 0.0f;

        // MacroDefinition @ FAudioFX.h:174:9
        public const float FAUDIOFX_REVERB_MAX_REFLECTIONS_GAIN = 20.0f;

        // MacroDefinition @ FAudioFX.h:175:9
        public const float FAUDIOFX_REVERB_MAX_REVERB_GAIN = 20.0f;

        // MacroDefinition @ FAudioFX.h:176:9
        public const float FAUDIOFX_REVERB_MAX_DENSITY = 100.0f;

        // MacroDefinition @ FAudioFX.h:177:9
        public const float FAUDIOFX_REVERB_MAX_ROOM_SIZE = 100.0f;

        // MacroDefinition @ FAudioFX.h:179:9
        public const float FAUDIOFX_REVERB_DEFAULT_WET_DRY_MIX = 100.0f;

        // MacroDefinition @ FAudioFX.h:180:9
        public const int FAUDIOFX_REVERB_DEFAULT_REFLECTIONS_DELAY = 5;

        // MacroDefinition @ FAudioFX.h:181:9
        public const int FAUDIOFX_REVERB_DEFAULT_REVERB_DELAY = 5;

        // MacroDefinition @ FAudioFX.h:182:9
        public const int FAUDIOFX_REVERB_DEFAULT_REAR_DELAY = 5;

        // MacroDefinition @ FAudioFX.h:183:9
        public const int FAUDIOFX_REVERB_DEFAULT_7POINT1_SIDE_DELAY = 5;

        // MacroDefinition @ FAudioFX.h:184:9
        public const int FAUDIOFX_REVERB_DEFAULT_7POINT1_REAR_DELAY = 20;

        // MacroDefinition @ FAudioFX.h:185:9
        public const int FAUDIOFX_REVERB_DEFAULT_POSITION = 6;

        // MacroDefinition @ FAudioFX.h:186:9
        public const int FAUDIOFX_REVERB_DEFAULT_POSITION_MATRIX = 27;

        // MacroDefinition @ FAudioFX.h:187:9
        public const int FAUDIOFX_REVERB_DEFAULT_EARLY_DIFFUSION = 8;

        // MacroDefinition @ FAudioFX.h:188:9
        public const int FAUDIOFX_REVERB_DEFAULT_LATE_DIFFUSION = 8;

        // MacroDefinition @ FAudioFX.h:189:9
        public const int FAUDIOFX_REVERB_DEFAULT_LOW_EQ_GAIN = 8;

        // MacroDefinition @ FAudioFX.h:190:9
        public const int FAUDIOFX_REVERB_DEFAULT_LOW_EQ_CUTOFF = 4;

        // MacroDefinition @ FAudioFX.h:191:9
        public const int FAUDIOFX_REVERB_DEFAULT_HIGH_EQ_GAIN = 8;

        // MacroDefinition @ FAudioFX.h:192:9
        public const int FAUDIOFX_REVERB_DEFAULT_HIGH_EQ_CUTOFF = 4;

        // MacroDefinition @ FAudioFX.h:193:9
        public const float FAUDIOFX_REVERB_DEFAULT_ROOM_FILTER_FREQ = 5000.0f;

        // MacroDefinition @ FAudioFX.h:194:9
        public const float FAUDIOFX_REVERB_DEFAULT_ROOM_FILTER_MAIN = 0.0f;

        // MacroDefinition @ FAudioFX.h:195:9
        public const float FAUDIOFX_REVERB_DEFAULT_ROOM_FILTER_HF = 0.0f;

        // MacroDefinition @ FAudioFX.h:196:9
        public const float FAUDIOFX_REVERB_DEFAULT_REFLECTIONS_GAIN = 0.0f;

        // MacroDefinition @ FAudioFX.h:197:9
        public const float FAUDIOFX_REVERB_DEFAULT_REVERB_GAIN = 0.0f;

        // MacroDefinition @ FAudioFX.h:198:9
        public const float FAUDIOFX_REVERB_DEFAULT_DECAY_TIME = 1.0f;

        // MacroDefinition @ FAudioFX.h:199:9
        public const float FAUDIOFX_REVERB_DEFAULT_DENSITY = 100.0f;

        // MacroDefinition @ FAudioFX.h:200:9
        public const float FAUDIOFX_REVERB_DEFAULT_ROOM_SIZE = 100.0f;

        #region C2CS.Runtime

        public static class Runtime
        {

            /// <summary>
            ///     A boolean value type with the same memory layout as a <see cref="byte" /> in both managed and unmanaged contexts;
            ///     equivalent to a standard bool found in C/C++/ObjC where <c>0</c> is <c>false</c> and any other value is
            ///     <c>true</c>.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CBool : IEquatable<CBool>
            {
                private readonly byte _value;

                private CBool(bool value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static implicit operator CBool(bool value)
                {
                    return FromBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static CBool FromBoolean(bool value)
                {
                    return new CBool(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static implicit operator bool(CBool value)
                {
                    return ToBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static bool ToBoolean(CBool value)
                {
                    return Convert.ToBoolean(value._value);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return ToBoolean(this).ToString();
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CBool b && Equals(b);
                }

                /// <inheritdoc />
                public bool Equals(CBool other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CBool left, CBool right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CBool left, CBool right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CBool left, CBool right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A value type with the same memory layout as a <see cref="byte" /> in a managed context and <c>char</c> in
            ///     an unmanaged context.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CChar : IEquatable<byte>, IEquatable<CChar>
            {
                private readonly byte _value;

                private CChar(byte value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static implicit operator CChar(byte value)
                {
                    return FromByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static CChar FromByte(byte value)
                {
                    return new CChar(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static implicit operator byte(CChar value)
                {
                    return ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static byte ToByte(CChar value)
                {
                    return value._value;
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return _value.ToString(CultureInfo.InvariantCulture);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CChar value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(byte other)
                {
                    return _value == other;
                }

                /// <inheritdoc />
                public bool Equals(CChar other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CChar left, CChar right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CChar left, CChar right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CChar left, CChar right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A value type with the memory layout of a <c>wchar_t</c> in an unmanaged context. The memory layout in a
            ///     managed context depends on the operating system or otherwise on preprocessor directives defines.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CCharWide : IEquatable<CCharWide>
            {
#if SIZEOF_WCHAR_T_1
    private readonly byte _value;
#elif SIZEOF_WCHAR_T_2
    private readonly ushort _value;
#elif SIZEOF_WCHAR_T_4
    private readonly uint _value;
#else
                private readonly ushort _value;
#endif

                private CCharWide(byte value)
                {
#if SIZEOF_WCHAR_T_1
        _value = Convert.ToByte(value);
#elif SIZEOF_WCHAR_T_2
        _value = Convert.ToUInt16(value);
#elif SIZEOF_WCHAR_T_4
        _value = Convert.ToUInt32(value);
#else
                    _value = Convert.ToUInt16(value);
#endif
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return _value.ToString(CultureInfo.InvariantCulture);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CCharWide value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CCharWide other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CCharWide left, CCharWide right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CCharWide left, CCharWide right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CCharWide left, CCharWide right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A pointer value type of bytes that represent a string; the C type `char*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CString : IEquatable<CString>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CString" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CString(string s)
                {
                    _pointer = CStrings.CString(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static explicit operator CString(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromIntPtr(nint value)
                {
                    return new CString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString From(byte* value)
                {
                    return new CString((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CString value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CString value)
                {
                    return CStrings.String(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromString(string s)
                {
                    return CStrings.CString(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.String(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CString value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CString other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CString left, CString right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }
            }

            /// <summary>
            ///     The collection of utility methods for interoperability with C style strings in C#.
            /// </summary>
            public static unsafe class CStrings
            {
                private static readonly Dictionary<uint, CString> StringHashesToPointers = new();
                private static readonly Dictionary<nint, string> PointersToStrings = new();
                private static readonly Dictionary<uint, CStringWide> StringHashesToPointersWide = new();
                private static readonly Dictionary<nint, string> PointersToStringsWide = new();

                /// <summary>
                ///     Converts a C style string (ANSI or UTF-8) of type `char` (one dimensional byte array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string String(CString value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStrings.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointers.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStrings[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringAnsi(value._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointers.Add(hash, value);
                    PointersToStrings.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a C style string (unicode) of type `wchar_t` (one dimensional ushort array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string StringWide(CStringWide value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStringsWide.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStringsWide[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringUni(pointer2._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointersWide.Add(hash, value);
                    PointersToStringsWide.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a UTF-16 <see cref="string" /> to a C style string (one dimensional byte array terminated by a
                ///     <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CString CString(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointers.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalAnsi(str);
                    StringHashesToPointers.Add(hash, new CString(pointer));
                    PointersToStrings.Add(pointer, str);

                    return new CString(pointer);
                }

                /// <summary>
                ///     Converts a C string pointer (one dimensional byte array terminated by a
                ///     <c>0x0</c>) for a specified <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CStringWide CStringWide(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalUni(str);
                    StringHashesToPointersWide.Add(hash, new CStringWide(pointer));
                    PointersToStringsWide.Add(pointer, str);

                    return new CStringWide(pointer);
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `char` (multi-dimensional array of one
                ///     dimensional byte arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CString* CStringArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CString*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CString(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `wchar_t` (multi-dimensional array of one
                ///     dimensional ushort arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CStringWide* CStringWideArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CStringWide*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CStringWide(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Frees the memory for all previously allocated C strings and releases references to all <see cref="string" />
                ///     objects which happened during <see cref="String" />, <see cref="StringWide" />, <see cref="CString" />
                ///     or <see cref="CStringWide" />. Does <b>not</b> garbage collect.
                /// </summary>
                public static void FreeAllStrings()
                {
                    foreach (var (ptr, _) in PointersToStrings)
                    {
                        Marshal.FreeHGlobal(ptr);
                    }

                    // We can not guarantee that the application has not a strong reference the string since it was allocated,
                    //  so we have to let the GC take the wheel here. Thus, this method should NOT garbage collect; that's
                    //  on the responsibility of the application developer. The best we can do is just remove any and all strong
                    //  references we have here to the strings.

                    StringHashesToPointers.Clear();
                    PointersToStrings.Clear();
                }

                /// <summary>
                ///     Frees the memory for specific previously allocated C strings and releases associated references to
                ///     <see cref="string" /> objects which happened during <see cref="String" /> or
                ///     <see cref="CString" />. Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="pointers">The C string pointers.</param>
                /// <param name="count">The number of C string pointers.</param>
                public static void FreeCStrings(CString* pointers, int count)
                {
                    for (var i = 0; i < count; i++)
                    {
                        var ptr = pointers[i];
                        FreeCString(ptr);
                    }

                    Marshal.FreeHGlobal((IntPtr)pointers);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="String" /> or <see cref="CString" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCString(CString value)
                {
                    if (!PointersToStrings.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointers.Remove(hash);
                    PointersToStrings.Remove(value._pointer);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="StringWide" /> or <see cref="CStringWide" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCStringWide(CStringWide value)
                {
                    if (!PointersToStringsWide.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointersWide.Remove(hash);
                    PointersToStringsWide.Remove(value._pointer);
                }

                // djb2 is named after https://en.wikipedia.org/wiki/Daniel_J._Bernstein
                //  References:
                //  (1) https://stackoverflow.com/a/7666577/2171957
                //  (2) http://www.cse.yorku.ca/~oz/hash.html
                //  (3) https://groups.google.com/g/comp.lang.c/c/lSKWXiuNOAk/m/zstZ3SRhCjgJ
                private static uint Djb2(byte* str)
                {
                    uint hash = 5381;

                    unchecked
                    {
                        uint c;
                        while ((c = *str++) != 0)
                        {
                            hash = (hash << 5) + hash + c; // hash * 33 + c
                        }
                    }

                    return hash;
                }

                private static uint Djb2(string str)
                {
                    uint hash = 5381;

                    // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
                    foreach (var c in str)
                    {
                        hash = (hash << 5) + hash + c; // hash * 33 + c
                    }

                    return hash;
                }
            }

            /// <summary>
            ///     A pointer value type that represents a wide string; C type `wchar_t*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CStringWide : IEquatable<CStringWide>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CStringWide" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CStringWide(string s)
                {
                    _pointer = CStrings.CStringWide(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static explicit operator CStringWide(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromIntPtr(nint value)
                {
                    return new CStringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide From(byte* value)
                {
                    return new CStringWide((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CStringWide value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CStringWide value)
                {
                    return CStrings.StringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromString(string s)
                {
                    return CStrings.CStringWide(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.StringWide(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CStringWide value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CStringWide other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CStringWide left, CStringWide right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }
            }
        }

        #endregion
    }
}

